// This file is automatically generated, so please do not edit it.
// Generated by `flutter_rust_bridge`@ 2.0.0-dev.25.

#![allow(
    non_camel_case_types,
    unused,
    non_snake_case,
    clippy::needless_return,
    clippy::redundant_closure_call,
    clippy::redundant_closure,
    clippy::useless_conversion,
    clippy::unit_arg,
    clippy::unused_unit,
    clippy::double_parens,
    clippy::let_and_return,
    clippy::too_many_arguments,
    clippy::match_single_binding
)]

// Section: imports

use flutter_rust_bridge::for_generated::byteorder::{NativeEndian, ReadBytesExt, WriteBytesExt};
use flutter_rust_bridge::for_generated::transform_result_dco;
use flutter_rust_bridge::{Handler, IntoIntoDart};

// Section: boilerplate

flutter_rust_bridge::frb_generated_boilerplate!(
    default_stream_sink_codec = SseCodec,
    default_rust_opaque = RustOpaqueMoi,
    default_rust_auto_opaque = RustAutoOpaqueMoi,
);
const FLUTTER_RUST_BRIDGE_CODEGEN_VERSION: &str = "2.0.0-dev.25";

// Section: executor

flutter_rust_bridge::frb_generated_default_handler!();

// Section: wire_funcs

fn wire_append_download_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "append_download",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_data =
                <crate::commons::udto::UIQueryDownloadComic>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse(
                    (move || async move { crate::api::api::append_download(api_data).await })()
                        .await,
                )
            }
        },
    )
}
fn wire_cache_image_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "cache_image",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_cache_key = <String>::sse_decode(&mut deserializer);
            let api_url = <String>::sse_decode(&mut deserializer);
            let api_useful = <String>::sse_decode(&mut deserializer);
            let api_extends_field_first = <Option<String>>::sse_decode(&mut deserializer);
            let api_extends_field_second = <Option<String>>::sse_decode(&mut deserializer);
            let api_extends_field_third = <Option<String>>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse(
                    (move || async move {
                        crate::api::api::cache_image(
                            api_cache_key,
                            api_url,
                            api_useful,
                            api_extends_field_first,
                            api_extends_field_second,
                            api_extends_field_third,
                        )
                        .await
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire_clean_cache_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "clean_cache",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_time = <i64>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse(
                    (move || async move { crate::api::api::clean_cache(api_time).await })().await,
                )
            }
        },
    )
}
fn wire_collect_from_account_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "collect_from_account",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_free_type = <i64>::sse_decode(&mut deserializer);
            let api_ordering = <String>::sse_decode(&mut deserializer);
            let api_offset = <u64>::sse_decode(&mut deserializer);
            let api_limit = <u64>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse(
                    (move || async move {
                        crate::api::api::collect_from_account(
                            api_free_type,
                            api_ordering,
                            api_offset,
                            api_limit,
                        )
                        .await
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire_collect_to_account_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "collect_to_account",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_comic_id = <String>::sse_decode(&mut deserializer);
            let api_is_collect = <bool>::sse_decode(&mut deserializer);
            let api_comic_path_word = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse(
                    (move || async move {
                        crate::api::api::collect_to_account(
                            api_comic_id,
                            api_is_collect,
                            api_comic_path_word,
                        )
                        .await
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire_comic_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "comic",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_path_word = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse(
                    (move || async move { crate::api::api::comic(api_path_word).await })().await,
                )
            }
        },
    )
}
fn wire_comic_chapter_data_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "comic_chapter_data",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_comic_path_word = <String>::sse_decode(&mut deserializer);
            let api_chapter_uuid = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse(
                    (move || async move {
                        crate::api::api::comic_chapter_data(api_comic_path_word, api_chapter_uuid)
                            .await
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire_comic_chapters_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "comic_chapters",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_comic_path_word = <String>::sse_decode(&mut deserializer);
            let api_group_path_word = <String>::sse_decode(&mut deserializer);
            let api_limit = <u64>::sse_decode(&mut deserializer);
            let api_offset = <u64>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse(
                    (move || async move {
                        crate::api::api::comic_chapters(
                            api_comic_path_word,
                            api_group_path_word,
                            api_limit,
                            api_offset,
                        )
                        .await
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire_comic_query_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "comic_query",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_path_word = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse(
                    (move || async move { crate::api::api::comic_query(api_path_word).await })()
                        .await,
                )
            }
        },
    )
}
fn wire_comic_search_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "comic_search",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_q_type = <String>::sse_decode(&mut deserializer);
            let api_q = <String>::sse_decode(&mut deserializer);
            let api_offset = <u64>::sse_decode(&mut deserializer);
            let api_limit = <u64>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse(
                    (move || async move {
                        crate::api::api::comic_search(api_q_type, api_q, api_offset, api_limit)
                            .await
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire_delete_download_comic_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "delete_download_comic",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_comic_path_word = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse(
                    (move || async move {
                        crate::api::api::delete_download_comic(api_comic_path_word).await
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire_download_comic_chapters_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "download_comic_chapters",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_comic_path_word = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse(
                    (move || async move {
                        crate::api::api::download_comic_chapters(api_comic_path_word).await
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire_download_comic_groups_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "download_comic_groups",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_comic_path_word = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse(
                    (move || async move {
                        crate::api::api::download_comic_groups(api_comic_path_word).await
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire_download_comic_pages_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "download_comic_pages",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_comic_path_word = <String>::sse_decode(&mut deserializer);
            let api_chapter_uuid = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse(
                    (move || async move {
                        crate::api::api::download_comic_pages(api_comic_path_word, api_chapter_uuid)
                            .await
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire_download_comics_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "download_comics",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            move |context| async move {
                transform_result_sse(
                    (move || async move { crate::api::api::download_comics().await })().await,
                )
            }
        },
    )
}
fn wire_download_is_pause_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "download_is_pause",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            move |context| async move {
                transform_result_sse(
                    (move || async move { crate::api::api::download_is_pause().await })().await,
                )
            }
        },
    )
}
fn wire_download_set_pause_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "download_set_pause",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_pause = <bool>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse(
                    (move || async move { crate::api::api::download_set_pause(api_pause).await })()
                        .await,
                )
            }
        },
    )
}
fn wire_explorer_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "explorer",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_ordering = <Option<String>>::sse_decode(&mut deserializer);
            let api_top = <Option<String>>::sse_decode(&mut deserializer);
            let api_theme = <Option<String>>::sse_decode(&mut deserializer);
            let api_offset = <u64>::sse_decode(&mut deserializer);
            let api_limit = <u64>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse(
                    (move || async move {
                        crate::api::api::explorer(
                            api_ordering,
                            api_top,
                            api_theme,
                            api_offset,
                            api_limit,
                        )
                        .await
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire_exports_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "exports",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_uuid_list = <Vec<String>>::sse_decode(&mut deserializer);
            let api_export_to_folder = <String>::sse_decode(&mut deserializer);
            let api_exports_type =
                <crate::commons::udto::ExportsType>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse(
                    (move || async move {
                        crate::api::api::exports(
                            api_uuid_list,
                            api_export_to_folder,
                            api_exports_type,
                        )
                        .await
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire_find_comic_view_log_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "find_comic_view_log",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_path_word = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse((move || async move {
                         crate::api::api::find_comic_view_log(api_path_word).await
                    })().await)
            }
        },
    )
}
fn wire_get_proxy_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "get_proxy",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            move |context| async move {
                transform_result_sse(
                    (move || async move { crate::api::api::get_proxy().await })().await,
                )
            }
        },
    )
}
fn wire_http_get_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "http_get",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_url = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse(
                    (move || async move { crate::api::api::http_get(api_url).await })().await,
                )
            }
        },
    )
}
fn wire_in_download_chapter_uuid_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "in_download_chapter_uuid",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_comic_path_word = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse(
                    (move || async move {
                        crate::api::api::in_download_chapter_uuid(api_comic_path_word).await
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire_init_login_state_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "init_login_state",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            move |context| async move {
                transform_result_sse(
                    (move || async move { crate::api::api::init_login_state().await })().await,
                )
            }
        },
    )
}
fn wire_list_comic_view_logs_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "list_comic_view_logs",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_offset = <i64>::sse_decode(&mut deserializer);
            let api_limit = <i64>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse(
                    (move || async move {
                        crate::api::api::list_comic_view_logs(api_offset, api_limit).await
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire_load_property_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "load_property",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_k = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse(
                    (move || async move { crate::api::api::load_property(api_k).await })().await,
                )
            }
        },
    )
}
fn wire_login_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "login",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_username = <String>::sse_decode(&mut deserializer);
            let api_password = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse((move || async move {
                         crate::api::api::login(api_username, api_password).await
                    })().await)
            }
        },
    )
}
fn wire_rank_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "rank",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_date_type = <String>::sse_decode(&mut deserializer);
            let api_offset = <u64>::sse_decode(&mut deserializer);
            let api_limit = <u64>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse(
                    (move || async move {
                        crate::api::api::rank(api_date_type, api_offset, api_limit).await
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire_recommends_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "recommends",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_offset = <u64>::sse_decode(&mut deserializer);
            let api_limit = <u64>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse((move || async move {
                         crate::api::api::recommends(api_offset, api_limit).await
                    })().await)
            }
        },
    )
}
fn wire_register_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "register",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_username = <String>::sse_decode(&mut deserializer);
            let api_password = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse((move || async move {
                         crate::api::api::register(api_username, api_password).await
                    })().await)
            }
        },
    )
}
fn wire_reset_fail_downloads_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "reset_fail_downloads",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            move |context| async move {
                transform_result_sse(
                    (move || async move { crate::api::api::reset_fail_downloads().await })().await,
                )
            }
        },
    )
}
fn wire_save_property_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "save_property",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_k = <String>::sse_decode(&mut deserializer);
            let api_v = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse(
                    (move || async move { crate::api::api::save_property(api_k, api_v).await })()
                        .await,
                )
            }
        },
    )
}
fn wire_set_proxy_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "set_proxy",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_proxy = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse(
                    (move || async move { crate::api::api::set_proxy(api_proxy).await })().await,
                )
            }
        },
    )
}
fn wire_tags_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "tags",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            move |context| async move {
                transform_result_sse((move || async move { crate::api::api::tags().await })().await)
            }
        },
    )
}
fn wire_view_chapter_page_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "view_chapter_page",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_comic_path_word = <String>::sse_decode(&mut deserializer);
            let api_chapter_uuid = <String>::sse_decode(&mut deserializer);
            let api_chapter_name = <String>::sse_decode(&mut deserializer);
            let api_chapter_ordered = <i64>::sse_decode(&mut deserializer);
            let api_chapter_size = <i64>::sse_decode(&mut deserializer);
            let api_chapter_count = <i64>::sse_decode(&mut deserializer);
            let api_page_rank = <i32>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse(
                    (move || async move {
                        crate::api::api::view_chapter_page(
                            api_comic_path_word,
                            api_chapter_uuid,
                            api_chapter_name,
                            api_chapter_ordered,
                            api_chapter_size,
                            api_chapter_count,
                            api_page_rank,
                        )
                        .await
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire_view_comic_info_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "view_comic_info",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_comic_path_word = <String>::sse_decode(&mut deserializer);
            let api_comic_name = <String>::sse_decode(&mut deserializer);
            let api_comic_authors =
                <Vec<crate::copy_client::dtos::Author>>::sse_decode(&mut deserializer);
            let api_comic_cover = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse(
                    (move || async move {
                        crate::api::api::view_comic_info(
                            api_comic_path_word,
                            api_comic_name,
                            api_comic_authors,
                            api_comic_cover,
                        )
                        .await
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire_desktop_root_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "desktop_root",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            transform_result_sse((move || crate::api::global::desktop_root())())
        },
    )
}
fn wire_init_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "init",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_root = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse(
                    (move || async move { crate::api::global::init(api_root).await })().await,
                )
            }
        },
    )
}
fn wire_init_app_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "init_app",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            move |context| {
                transform_result_sse(
                    (move || Result::<_, ()>::Ok(crate::api::global::init_app()))(),
                )
            }
        },
    )
}

// Section: dart2rust

impl SseDecode for flutter_rust_bridge::for_generated::anyhow::Error {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        unreachable!("");
    }
}

impl SseDecode for String {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <Vec<u8>>::sse_decode(deserializer);
        return String::from_utf8(inner).unwrap();
    }
}

impl SseDecode for crate::copy_client::dtos::Author {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_name = <String>::sse_decode(deserializer);
        let mut var_alias = <Option<String>>::sse_decode(deserializer);
        let mut var_pathWord = <String>::sse_decode(deserializer);
        return crate::copy_client::dtos::Author {
            name: var_name,
            alias: var_alias,
            path_word: var_pathWord,
        };
    }
}

impl SseDecode for bool {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_u8().unwrap() != 0
    }
}

impl SseDecode for crate::copy_client::dtos::Browse {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_chapterId = <String>::sse_decode(deserializer);
        let mut var_chapterName = <String>::sse_decode(deserializer);
        let mut var_chapterUuid = <String>::sse_decode(deserializer);
        let mut var_comicId = <String>::sse_decode(deserializer);
        let mut var_comicUuid = <String>::sse_decode(deserializer);
        let mut var_pathWord = <String>::sse_decode(deserializer);
        return crate::copy_client::dtos::Browse {
            chapter_id: var_chapterId,
            chapter_name: var_chapterName,
            chapter_uuid: var_chapterUuid,
            comic_id: var_comicId,
            comic_uuid: var_comicUuid,
            path_word: var_pathWord,
        };
    }
}

impl SseDecode for crate::copy_client::dtos::ChapterComicInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_name = <String>::sse_decode(deserializer);
        let mut var_pathWord = <String>::sse_decode(deserializer);
        let mut var_restrict = <crate::copy_client::dtos::ClassifyItem>::sse_decode(deserializer);
        let mut var_uuid = <String>::sse_decode(deserializer);
        return crate::copy_client::dtos::ChapterComicInfo {
            name: var_name,
            path_word: var_pathWord,
            restrict: var_restrict,
            uuid: var_uuid,
        };
    }
}

impl SseDecode for crate::copy_client::dtos::ChapterImage {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_url = <String>::sse_decode(deserializer);
        return crate::copy_client::dtos::ChapterImage { url: var_url };
    }
}

impl SseDecode for crate::copy_client::dtos::ClassifyItem {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_display = <String>::sse_decode(deserializer);
        let mut var_value = <i64>::sse_decode(deserializer);
        return crate::copy_client::dtos::ClassifyItem {
            display: var_display,
            value: var_value,
        };
    }
}

impl SseDecode for crate::copy_client::dtos::CollectedComic {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_uuid = <i64>::sse_decode(deserializer);
        let mut var_name = <Option<String>>::sse_decode(deserializer);
        let mut var_bFolder = <bool>::sse_decode(deserializer);
        let mut var_folderId = <Option<String>>::sse_decode(deserializer);
        let mut var_lastBrowse =
            <Option<crate::copy_client::dtos::LastBrowse>>::sse_decode(deserializer);
        let mut var_comic =
            <crate::copy_client::dtos::CollectedComicInfo>::sse_decode(deserializer);
        return crate::copy_client::dtos::CollectedComic {
            uuid: var_uuid,
            name: var_name,
            b_folder: var_bFolder,
            folder_id: var_folderId,
            last_browse: var_lastBrowse,
            comic: var_comic,
        };
    }
}

impl SseDecode for crate::copy_client::dtos::CollectedComicInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_uuid = <String>::sse_decode(deserializer);
        let mut var_bDisplay = <bool>::sse_decode(deserializer);
        let mut var_name = <String>::sse_decode(deserializer);
        let mut var_pathWord = <String>::sse_decode(deserializer);
        let mut var_females =
            <Vec<crate::copy_client::dtos::SexualOrientation>>::sse_decode(deserializer);
        let mut var_males =
            <Vec<crate::copy_client::dtos::SexualOrientation>>::sse_decode(deserializer);
        let mut var_author = <Vec<crate::copy_client::dtos::Author>>::sse_decode(deserializer);
        let mut var_theme = <Vec<crate::copy_client::dtos::Tag>>::sse_decode(deserializer);
        let mut var_cover = <String>::sse_decode(deserializer);
        let mut var_status = <i64>::sse_decode(deserializer);
        let mut var_popular = <i64>::sse_decode(deserializer);
        let mut var_datetimeUpdated = <String>::sse_decode(deserializer);
        let mut var_lastChapterId = <String>::sse_decode(deserializer);
        let mut var_lastChapterName = <String>::sse_decode(deserializer);
        return crate::copy_client::dtos::CollectedComicInfo {
            uuid: var_uuid,
            b_display: var_bDisplay,
            name: var_name,
            path_word: var_pathWord,
            females: var_females,
            males: var_males,
            author: var_author,
            theme: var_theme,
            cover: var_cover,
            status: var_status,
            popular: var_popular,
            datetime_updated: var_datetimeUpdated,
            last_chapter_id: var_lastChapterId,
            last_chapter_name: var_lastChapterName,
        };
    }
}

impl SseDecode for crate::commons::udto::ExportsType {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => crate::commons::udto::ExportsType::Folder,
            1 => crate::commons::udto::ExportsType::Zip,
            _ => unreachable!("Invalid variant for ExportsType: {}", inner),
        };
    }
}

impl SseDecode for crate::copy_client::dtos::Group {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_count = <i64>::sse_decode(deserializer);
        let mut var_name = <String>::sse_decode(deserializer);
        let mut var_pathWord = <String>::sse_decode(deserializer);
        return crate::copy_client::dtos::Group {
            count: var_count,
            name: var_name,
            path_word: var_pathWord,
        };
    }
}

impl SseDecode for i32 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_i32::<NativeEndian>().unwrap()
    }
}

impl SseDecode for i64 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_i64::<NativeEndian>().unwrap()
    }
}

impl SseDecode for crate::copy_client::dtos::LastBrowse {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_lastBrowseId = <String>::sse_decode(deserializer);
        let mut var_lastBrowseName = <String>::sse_decode(deserializer);
        return crate::copy_client::dtos::LastBrowse {
            last_browse_id: var_lastBrowseId,
            last_browse_name: var_lastBrowseName,
        };
    }
}

impl SseDecode for crate::copy_client::dtos::LastChapter {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_name = <String>::sse_decode(deserializer);
        let mut var_uuid = <String>::sse_decode(deserializer);
        return crate::copy_client::dtos::LastChapter {
            name: var_name,
            uuid: var_uuid,
        };
    }
}

impl SseDecode for Vec<String> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<String>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::copy_client::dtos::Author> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::copy_client::dtos::Author>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::copy_client::dtos::ChapterImage> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::copy_client::dtos::ChapterImage>::sse_decode(
                deserializer,
            ));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::copy_client::dtos::CollectedComic> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::copy_client::dtos::CollectedComic>::sse_decode(
                deserializer,
            ));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::copy_client::dtos::Group> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::copy_client::dtos::Group>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<i64> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<i64>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<u8> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<u8>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::copy_client::dtos::SexualOrientation> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::copy_client::dtos::SexualOrientation>::sse_decode(
                deserializer,
            ));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::copy_client::dtos::Tag> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::copy_client::dtos::Tag>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::commons::udto::UIComicChapter> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::commons::udto::UIComicChapter>::sse_decode(
                deserializer,
            ));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::commons::udto::UIComicInExplore> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::commons::udto::UIComicInExplore>::sse_decode(
                deserializer,
            ));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::commons::udto::UIComicInList> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::commons::udto::UIComicInList>::sse_decode(
                deserializer,
            ));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::commons::udto::UIDownloadComic> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::commons::udto::UIDownloadComic>::sse_decode(
                deserializer,
            ));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::commons::udto::UIDownloadComicChapter> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::commons::udto::UIDownloadComicChapter>::sse_decode(
                deserializer,
            ));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::commons::udto::UIDownloadComicGroup> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::commons::udto::UIDownloadComicGroup>::sse_decode(
                deserializer,
            ));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::commons::udto::UIDownloadComicPage> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::commons::udto::UIDownloadComicPage>::sse_decode(
                deserializer,
            ));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::commons::udto::UIQueryDownloadComicChapter> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(
                <crate::commons::udto::UIQueryDownloadComicChapter>::sse_decode(deserializer),
            );
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::commons::udto::UIQueryDownloadComicGroup> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::commons::udto::UIQueryDownloadComicGroup>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::commons::udto::UIRankItem> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::commons::udto::UIRankItem>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::commons::udto::UITheme> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::commons::udto::UITheme>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::commons::udto::UIViewLog> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::commons::udto::UIViewLog>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for crate::copy_client::dtos::MemberInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_userId = <String>::sse_decode(deserializer);
        let mut var_username = <String>::sse_decode(deserializer);
        let mut var_nickname = <String>::sse_decode(deserializer);
        let mut var_avatar = <String>::sse_decode(deserializer);
        let mut var_isAuthenticated = <bool>::sse_decode(deserializer);
        let mut var_datetimeCreated = <String>::sse_decode(deserializer);
        let mut var_bVerifyEmail = <bool>::sse_decode(deserializer);
        let mut var_email = <String>::sse_decode(deserializer);
        let mut var_mobile = <Option<String>>::sse_decode(deserializer);
        let mut var_mobileRegion = <Option<String>>::sse_decode(deserializer);
        let mut var_point = <i64>::sse_decode(deserializer);
        let mut var_comicVip = <i64>::sse_decode(deserializer);
        let mut var_comicVipEnd = <Option<String>>::sse_decode(deserializer);
        let mut var_comicVipStart = <Option<String>>::sse_decode(deserializer);
        let mut var_cartoonVip = <i64>::sse_decode(deserializer);
        let mut var_cartoonVipEnd = <Option<String>>::sse_decode(deserializer);
        let mut var_cartoonVipStart = <Option<String>>::sse_decode(deserializer);
        let mut var_adsVipEnd = <Option<String>>::sse_decode(deserializer);
        let mut var_closeReport = <bool>::sse_decode(deserializer);
        let mut var_downloads = <i64>::sse_decode(deserializer);
        let mut var_vipDownloads = <i64>::sse_decode(deserializer);
        let mut var_rewardDownloads = <i64>::sse_decode(deserializer);
        let mut var_inviteCode = <Option<String>>::sse_decode(deserializer);
        let mut var_invited = <Option<String>>::sse_decode(deserializer);
        let mut var_bSstv = <bool>::sse_decode(deserializer);
        let mut var_scyAnswer = <bool>::sse_decode(deserializer);
        let mut var_dayDownloadsRefresh = <String>::sse_decode(deserializer);
        let mut var_dayDownloads = <i64>::sse_decode(deserializer);
        return crate::copy_client::dtos::MemberInfo {
            user_id: var_userId,
            username: var_username,
            nickname: var_nickname,
            avatar: var_avatar,
            is_authenticated: var_isAuthenticated,
            datetime_created: var_datetimeCreated,
            b_verify_email: var_bVerifyEmail,
            email: var_email,
            mobile: var_mobile,
            mobile_region: var_mobileRegion,
            point: var_point,
            comic_vip: var_comicVip,
            comic_vip_end: var_comicVipEnd,
            comic_vip_start: var_comicVipStart,
            cartoon_vip: var_cartoonVip,
            cartoon_vip_end: var_cartoonVipEnd,
            cartoon_vip_start: var_cartoonVipStart,
            ads_vip_end: var_adsVipEnd,
            close_report: var_closeReport,
            downloads: var_downloads,
            vip_downloads: var_vipDownloads,
            reward_downloads: var_rewardDownloads,
            invite_code: var_inviteCode,
            invited: var_invited,
            b_sstv: var_bSstv,
            scy_answer: var_scyAnswer,
            day_downloads_refresh: var_dayDownloadsRefresh,
            day_downloads: var_dayDownloads,
        };
    }
}

impl SseDecode for Option<String> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<String>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::copy_client::dtos::Browse> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::copy_client::dtos::Browse>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<i64> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<i64>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::copy_client::dtos::LastBrowse> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::copy_client::dtos::LastBrowse>::sse_decode(
                deserializer,
            ));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::copy_client::dtos::MemberInfo> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::copy_client::dtos::MemberInfo>::sse_decode(
                deserializer,
            ));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::copy_client::dtos::RegisterResult> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::copy_client::dtos::RegisterResult>::sse_decode(
                deserializer,
            ));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::commons::udto::UIViewLog> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::commons::udto::UIViewLog>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for crate::copy_client::dtos::RegisterResult {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_userId = <String>::sse_decode(deserializer);
        let mut var_uuid = <String>::sse_decode(deserializer);
        let mut var_datetimeCreated = <String>::sse_decode(deserializer);
        let mut var_token = <Option<String>>::sse_decode(deserializer);
        let mut var_nickname = <String>::sse_decode(deserializer);
        let mut var_avatar = <String>::sse_decode(deserializer);
        let mut var_inviteCode = <Option<String>>::sse_decode(deserializer);
        return crate::copy_client::dtos::RegisterResult {
            user_id: var_userId,
            uuid: var_uuid,
            datetime_created: var_datetimeCreated,
            token: var_token,
            nickname: var_nickname,
            avatar: var_avatar,
            invite_code: var_inviteCode,
        };
    }
}

impl SseDecode for crate::copy_client::dtos::SexualOrientation {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_name = <String>::sse_decode(deserializer);
        let mut var_pathWord = <String>::sse_decode(deserializer);
        let mut var_gender = <i64>::sse_decode(deserializer);
        return crate::copy_client::dtos::SexualOrientation {
            name: var_name,
            path_word: var_pathWord,
            gender: var_gender,
        };
    }
}

impl SseDecode for crate::copy_client::dtos::Tag {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_name = <String>::sse_decode(deserializer);
        let mut var_pathWord = <String>::sse_decode(deserializer);
        return crate::copy_client::dtos::Tag {
            name: var_name,
            path_word: var_pathWord,
        };
    }
}

impl SseDecode for u32 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_u32::<NativeEndian>().unwrap()
    }
}

impl SseDecode for u64 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_u64::<NativeEndian>().unwrap()
    }
}

impl SseDecode for u8 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_u8().unwrap()
    }
}

impl SseDecode for crate::commons::udto::UICacheImage {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_absPath = <String>::sse_decode(deserializer);
        let mut var_cacheKey = <String>::sse_decode(deserializer);
        let mut var_cacheTime = <i64>::sse_decode(deserializer);
        let mut var_url = <String>::sse_decode(deserializer);
        let mut var_useful = <String>::sse_decode(deserializer);
        let mut var_extendsFieldFirst = <Option<String>>::sse_decode(deserializer);
        let mut var_extendsFieldSecond = <Option<String>>::sse_decode(deserializer);
        let mut var_extendsFieldThird = <Option<String>>::sse_decode(deserializer);
        let mut var_localPath = <String>::sse_decode(deserializer);
        let mut var_imageFormat = <String>::sse_decode(deserializer);
        let mut var_imageWidth = <u32>::sse_decode(deserializer);
        let mut var_imageHeight = <u32>::sse_decode(deserializer);
        return crate::commons::udto::UICacheImage {
            abs_path: var_absPath,
            cache_key: var_cacheKey,
            cache_time: var_cacheTime,
            url: var_url,
            useful: var_useful,
            extends_field_first: var_extendsFieldFirst,
            extends_field_second: var_extendsFieldSecond,
            extends_field_third: var_extendsFieldThird,
            local_path: var_localPath,
            image_format: var_imageFormat,
            image_width: var_imageWidth,
            image_height: var_imageHeight,
        };
    }
}

impl SseDecode for crate::commons::udto::UIChapterAndContents {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_comicId = <String>::sse_decode(deserializer);
        let mut var_comicPathWord = <String>::sse_decode(deserializer);
        let mut var_contents =
            <Vec<crate::copy_client::dtos::ChapterImage>>::sse_decode(deserializer);
        let mut var_count = <i64>::sse_decode(deserializer);
        let mut var_datetimeCreated = <String>::sse_decode(deserializer);
        let mut var_groupPathWord = <String>::sse_decode(deserializer);
        let mut var_imgType = <i64>::sse_decode(deserializer);
        let mut var_index = <i64>::sse_decode(deserializer);
        let mut var_isLong = <bool>::sse_decode(deserializer);
        let mut var_name = <String>::sse_decode(deserializer);
        let mut var_news = <String>::sse_decode(deserializer);
        let mut var_next = <Option<String>>::sse_decode(deserializer);
        let mut var_ordered = <i64>::sse_decode(deserializer);
        let mut var_prev = <Option<String>>::sse_decode(deserializer);
        let mut var_size = <i64>::sse_decode(deserializer);
        let mut var_typeField = <i64>::sse_decode(deserializer);
        let mut var_uuid = <String>::sse_decode(deserializer);
        let mut var_words = <Vec<i64>>::sse_decode(deserializer);
        return crate::commons::udto::UIChapterAndContents {
            comic_id: var_comicId,
            comic_path_word: var_comicPathWord,
            contents: var_contents,
            count: var_count,
            datetime_created: var_datetimeCreated,
            group_path_word: var_groupPathWord,
            img_type: var_imgType,
            index: var_index,
            is_long: var_isLong,
            name: var_name,
            news: var_news,
            next: var_next,
            ordered: var_ordered,
            prev: var_prev,
            size: var_size,
            type_field: var_typeField,
            uuid: var_uuid,
            words: var_words,
        };
    }
}

impl SseDecode for crate::commons::udto::UIChapterData {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_chapter =
            <crate::commons::udto::UIChapterAndContents>::sse_decode(deserializer);
        let mut var_comic = <crate::copy_client::dtos::ChapterComicInfo>::sse_decode(deserializer);
        let mut var_isLock = <bool>::sse_decode(deserializer);
        let mut var_isLogin = <bool>::sse_decode(deserializer);
        let mut var_isMobileBind = <bool>::sse_decode(deserializer);
        let mut var_isVip = <bool>::sse_decode(deserializer);
        let mut var_showApp = <bool>::sse_decode(deserializer);
        return crate::commons::udto::UIChapterData {
            chapter: var_chapter,
            comic: var_comic,
            is_lock: var_isLock,
            is_login: var_isLogin,
            is_mobile_bind: var_isMobileBind,
            is_vip: var_isVip,
            show_app: var_showApp,
        };
    }
}

impl SseDecode for crate::commons::udto::UIComic {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_alias = <Option<String>>::sse_decode(deserializer);
        let mut var_author = <Vec<crate::copy_client::dtos::Author>>::sse_decode(deserializer);
        let mut var_b404 = <bool>::sse_decode(deserializer);
        let mut var_bHidden = <bool>::sse_decode(deserializer);
        let mut var_ban = <i64>::sse_decode(deserializer);
        let mut var_brief = <String>::sse_decode(deserializer);
        let mut var_closeComment = <bool>::sse_decode(deserializer);
        let mut var_closeRoast = <bool>::sse_decode(deserializer);
        let mut var_cover = <String>::sse_decode(deserializer);
        let mut var_datetimeUpdated = <String>::sse_decode(deserializer);
        let mut var_freeType = <crate::copy_client::dtos::ClassifyItem>::sse_decode(deserializer);
        let mut var_imgType = <i64>::sse_decode(deserializer);
        let mut var_lastChapter = <crate::copy_client::dtos::LastChapter>::sse_decode(deserializer);
        let mut var_name = <String>::sse_decode(deserializer);
        let mut var_pathWord = <String>::sse_decode(deserializer);
        let mut var_popular = <i64>::sse_decode(deserializer);
        let mut var_reclass = <crate::copy_client::dtos::ClassifyItem>::sse_decode(deserializer);
        let mut var_region = <crate::copy_client::dtos::ClassifyItem>::sse_decode(deserializer);
        let mut var_restrict = <crate::copy_client::dtos::ClassifyItem>::sse_decode(deserializer);
        let mut var_seoBaidu = <String>::sse_decode(deserializer);
        let mut var_status = <crate::copy_client::dtos::ClassifyItem>::sse_decode(deserializer);
        let mut var_theme = <Vec<crate::copy_client::dtos::Tag>>::sse_decode(deserializer);
        let mut var_uuid = <String>::sse_decode(deserializer);
        let mut var_females =
            <Vec<crate::copy_client::dtos::SexualOrientation>>::sse_decode(deserializer);
        let mut var_males =
            <Vec<crate::copy_client::dtos::SexualOrientation>>::sse_decode(deserializer);
        return crate::commons::udto::UIComic {
            alias: var_alias,
            author: var_author,
            b_404: var_b404,
            b_hidden: var_bHidden,
            ban: var_ban,
            brief: var_brief,
            close_comment: var_closeComment,
            close_roast: var_closeRoast,
            cover: var_cover,
            datetime_updated: var_datetimeUpdated,
            free_type: var_freeType,
            img_type: var_imgType,
            last_chapter: var_lastChapter,
            name: var_name,
            path_word: var_pathWord,
            popular: var_popular,
            reclass: var_reclass,
            region: var_region,
            restrict: var_restrict,
            seo_baidu: var_seoBaidu,
            status: var_status,
            theme: var_theme,
            uuid: var_uuid,
            females: var_females,
            males: var_males,
        };
    }
}

impl SseDecode for crate::commons::udto::UIComicChapter {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_comicId = <String>::sse_decode(deserializer);
        let mut var_comicPathWord = <String>::sse_decode(deserializer);
        let mut var_count = <i64>::sse_decode(deserializer);
        let mut var_datetimeCreated = <String>::sse_decode(deserializer);
        let mut var_groupPathWord = <String>::sse_decode(deserializer);
        let mut var_imgType = <i64>::sse_decode(deserializer);
        let mut var_index = <i64>::sse_decode(deserializer);
        let mut var_name = <String>::sse_decode(deserializer);
        let mut var_news = <String>::sse_decode(deserializer);
        let mut var_next = <Option<String>>::sse_decode(deserializer);
        let mut var_ordered = <i64>::sse_decode(deserializer);
        let mut var_prev = <Option<String>>::sse_decode(deserializer);
        let mut var_size = <i64>::sse_decode(deserializer);
        let mut var_typeField = <i64>::sse_decode(deserializer);
        let mut var_uuid = <String>::sse_decode(deserializer);
        return crate::commons::udto::UIComicChapter {
            comic_id: var_comicId,
            comic_path_word: var_comicPathWord,
            count: var_count,
            datetime_created: var_datetimeCreated,
            group_path_word: var_groupPathWord,
            img_type: var_imgType,
            index: var_index,
            name: var_name,
            news: var_news,
            next: var_next,
            ordered: var_ordered,
            prev: var_prev,
            size: var_size,
            type_field: var_typeField,
            uuid: var_uuid,
        };
    }
}

impl SseDecode for crate::commons::udto::UIComicData {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_comic = <crate::commons::udto::UIComic>::sse_decode(deserializer);
        let mut var_groups = <Vec<crate::copy_client::dtos::Group>>::sse_decode(deserializer);
        let mut var_isLock = <bool>::sse_decode(deserializer);
        let mut var_isLogin = <bool>::sse_decode(deserializer);
        let mut var_isMobileBind = <bool>::sse_decode(deserializer);
        let mut var_isVip = <bool>::sse_decode(deserializer);
        let mut var_popular = <i64>::sse_decode(deserializer);
        return crate::commons::udto::UIComicData {
            comic: var_comic,
            groups: var_groups,
            is_lock: var_isLock,
            is_login: var_isLogin,
            is_mobile_bind: var_isMobileBind,
            is_vip: var_isVip,
            popular: var_popular,
        };
    }
}

impl SseDecode for crate::commons::udto::UIComicInExplore {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_name = <String>::sse_decode(deserializer);
        let mut var_pathWord = <String>::sse_decode(deserializer);
        let mut var_freeType = <crate::copy_client::dtos::ClassifyItem>::sse_decode(deserializer);
        let mut var_author = <Vec<crate::copy_client::dtos::Author>>::sse_decode(deserializer);
        let mut var_cover = <String>::sse_decode(deserializer);
        let mut var_popular = <i64>::sse_decode(deserializer);
        let mut var_datetimeUpdated = <Option<String>>::sse_decode(deserializer);
        let mut var_females =
            <Vec<crate::copy_client::dtos::SexualOrientation>>::sse_decode(deserializer);
        let mut var_males =
            <Vec<crate::copy_client::dtos::SexualOrientation>>::sse_decode(deserializer);
        return crate::commons::udto::UIComicInExplore {
            name: var_name,
            path_word: var_pathWord,
            free_type: var_freeType,
            author: var_author,
            cover: var_cover,
            popular: var_popular,
            datetime_updated: var_datetimeUpdated,
            females: var_females,
            males: var_males,
        };
    }
}

impl SseDecode for crate::commons::udto::UIComicInList {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_author = <Vec<crate::copy_client::dtos::Author>>::sse_decode(deserializer);
        let mut var_cover = <String>::sse_decode(deserializer);
        let mut var_imgType = <i64>::sse_decode(deserializer);
        let mut var_name = <String>::sse_decode(deserializer);
        let mut var_pathWord = <String>::sse_decode(deserializer);
        let mut var_popular = <i64>::sse_decode(deserializer);
        let mut var_females =
            <Vec<crate::copy_client::dtos::SexualOrientation>>::sse_decode(deserializer);
        let mut var_males =
            <Vec<crate::copy_client::dtos::SexualOrientation>>::sse_decode(deserializer);
        return crate::commons::udto::UIComicInList {
            author: var_author,
            cover: var_cover,
            img_type: var_imgType,
            name: var_name,
            path_word: var_pathWord,
            popular: var_popular,
            females: var_females,
            males: var_males,
        };
    }
}

impl SseDecode for crate::commons::udto::UIComicQuery {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_browse = <Option<crate::copy_client::dtos::Browse>>::sse_decode(deserializer);
        let mut var_collect = <Option<i64>>::sse_decode(deserializer);
        let mut var_isLock = <bool>::sse_decode(deserializer);
        let mut var_isLogin = <bool>::sse_decode(deserializer);
        let mut var_isMobileBind = <bool>::sse_decode(deserializer);
        let mut var_isVip = <bool>::sse_decode(deserializer);
        return crate::commons::udto::UIComicQuery {
            browse: var_browse,
            collect: var_collect,
            is_lock: var_isLock,
            is_login: var_isLogin,
            is_mobile_bind: var_isMobileBind,
            is_vip: var_isVip,
        };
    }
}

impl SseDecode for crate::commons::udto::UIDownloadComic {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_pathWord = <String>::sse_decode(deserializer);
        let mut var_alias = <Option<String>>::sse_decode(deserializer);
        let mut var_author = <String>::sse_decode(deserializer);
        let mut var_b404 = <bool>::sse_decode(deserializer);
        let mut var_bHidden = <bool>::sse_decode(deserializer);
        let mut var_ban = <i64>::sse_decode(deserializer);
        let mut var_brief = <String>::sse_decode(deserializer);
        let mut var_closeComment = <bool>::sse_decode(deserializer);
        let mut var_closeRoast = <bool>::sse_decode(deserializer);
        let mut var_cover = <String>::sse_decode(deserializer);
        let mut var_datetimeUpdated = <String>::sse_decode(deserializer);
        let mut var_females = <String>::sse_decode(deserializer);
        let mut var_freeType = <String>::sse_decode(deserializer);
        let mut var_imgType = <i64>::sse_decode(deserializer);
        let mut var_males = <String>::sse_decode(deserializer);
        let mut var_name = <String>::sse_decode(deserializer);
        let mut var_popular = <i64>::sse_decode(deserializer);
        let mut var_reclass = <String>::sse_decode(deserializer);
        let mut var_region = <String>::sse_decode(deserializer);
        let mut var_restrict = <String>::sse_decode(deserializer);
        let mut var_seoBaidu = <String>::sse_decode(deserializer);
        let mut var_status = <String>::sse_decode(deserializer);
        let mut var_theme = <String>::sse_decode(deserializer);
        let mut var_uuid = <String>::sse_decode(deserializer);
        let mut var_coverCacheKey = <String>::sse_decode(deserializer);
        let mut var_coverDownloadStatus = <i64>::sse_decode(deserializer);
        let mut var_coverFormat = <String>::sse_decode(deserializer);
        let mut var_coverWidth = <u32>::sse_decode(deserializer);
        let mut var_coverHeight = <u32>::sse_decode(deserializer);
        let mut var_imageCount = <i64>::sse_decode(deserializer);
        let mut var_imageCountSuccess = <i64>::sse_decode(deserializer);
        let mut var_downloadStatus = <i64>::sse_decode(deserializer);
        return crate::commons::udto::UIDownloadComic {
            path_word: var_pathWord,
            alias: var_alias,
            author: var_author,
            b_404: var_b404,
            b_hidden: var_bHidden,
            ban: var_ban,
            brief: var_brief,
            close_comment: var_closeComment,
            close_roast: var_closeRoast,
            cover: var_cover,
            datetime_updated: var_datetimeUpdated,
            females: var_females,
            free_type: var_freeType,
            img_type: var_imgType,
            males: var_males,
            name: var_name,
            popular: var_popular,
            reclass: var_reclass,
            region: var_region,
            restrict: var_restrict,
            seo_baidu: var_seoBaidu,
            status: var_status,
            theme: var_theme,
            uuid: var_uuid,
            cover_cache_key: var_coverCacheKey,
            cover_download_status: var_coverDownloadStatus,
            cover_format: var_coverFormat,
            cover_width: var_coverWidth,
            cover_height: var_coverHeight,
            image_count: var_imageCount,
            image_count_success: var_imageCountSuccess,
            download_status: var_downloadStatus,
        };
    }
}

impl SseDecode for crate::commons::udto::UIDownloadComicChapter {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_comicPathWord = <String>::sse_decode(deserializer);
        let mut var_uuid = <String>::sse_decode(deserializer);
        let mut var_comicId = <String>::sse_decode(deserializer);
        let mut var_count = <i64>::sse_decode(deserializer);
        let mut var_datetimeCreated = <String>::sse_decode(deserializer);
        let mut var_groupPathWord = <String>::sse_decode(deserializer);
        let mut var_imgType = <i64>::sse_decode(deserializer);
        let mut var_index = <i64>::sse_decode(deserializer);
        let mut var_isLong = <bool>::sse_decode(deserializer);
        let mut var_name = <String>::sse_decode(deserializer);
        let mut var_news = <String>::sse_decode(deserializer);
        let mut var_next = <Option<String>>::sse_decode(deserializer);
        let mut var_ordered = <i64>::sse_decode(deserializer);
        let mut var_prev = <Option<String>>::sse_decode(deserializer);
        let mut var_size = <i64>::sse_decode(deserializer);
        let mut var_typeField = <i64>::sse_decode(deserializer);
        let mut var_downloadStatus = <i64>::sse_decode(deserializer);
        return crate::commons::udto::UIDownloadComicChapter {
            comic_path_word: var_comicPathWord,
            uuid: var_uuid,
            comic_id: var_comicId,
            count: var_count,
            datetime_created: var_datetimeCreated,
            group_path_word: var_groupPathWord,
            img_type: var_imgType,
            index: var_index,
            is_long: var_isLong,
            name: var_name,
            news: var_news,
            next: var_next,
            ordered: var_ordered,
            prev: var_prev,
            size: var_size,
            type_field: var_typeField,
            download_status: var_downloadStatus,
        };
    }
}

impl SseDecode for crate::commons::udto::UIDownloadComicGroup {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_comicPathWord = <String>::sse_decode(deserializer);
        let mut var_groupPathWord = <String>::sse_decode(deserializer);
        let mut var_count = <i64>::sse_decode(deserializer);
        let mut var_name = <String>::sse_decode(deserializer);
        let mut var_groupRank = <i64>::sse_decode(deserializer);
        return crate::commons::udto::UIDownloadComicGroup {
            comic_path_word: var_comicPathWord,
            group_path_word: var_groupPathWord,
            count: var_count,
            name: var_name,
            group_rank: var_groupRank,
        };
    }
}

impl SseDecode for crate::commons::udto::UIDownloadComicPage {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_comicPathWord = <String>::sse_decode(deserializer);
        let mut var_chapterUuid = <String>::sse_decode(deserializer);
        let mut var_imageIndex = <i32>::sse_decode(deserializer);
        let mut var_url = <String>::sse_decode(deserializer);
        let mut var_cacheKey = <String>::sse_decode(deserializer);
        let mut var_downloadStatus = <i64>::sse_decode(deserializer);
        let mut var_width = <u32>::sse_decode(deserializer);
        let mut var_height = <u32>::sse_decode(deserializer);
        let mut var_format = <String>::sse_decode(deserializer);
        return crate::commons::udto::UIDownloadComicPage {
            comic_path_word: var_comicPathWord,
            chapter_uuid: var_chapterUuid,
            image_index: var_imageIndex,
            url: var_url,
            cache_key: var_cacheKey,
            download_status: var_downloadStatus,
            width: var_width,
            height: var_height,
            format: var_format,
        };
    }
}

impl SseDecode for crate::commons::udto::UILoginState {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_state = <i64>::sse_decode(deserializer);
        let mut var_message = <String>::sse_decode(deserializer);
        let mut var_member =
            <Option<crate::copy_client::dtos::MemberInfo>>::sse_decode(deserializer);
        return crate::commons::udto::UILoginState {
            state: var_state,
            message: var_message,
            member: var_member,
        };
    }
}

impl SseDecode for crate::commons::udto::UIPageCollectedComic {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_list =
            <Vec<crate::copy_client::dtos::CollectedComic>>::sse_decode(deserializer);
        let mut var_total = <i64>::sse_decode(deserializer);
        let mut var_limit = <i64>::sse_decode(deserializer);
        let mut var_offset = <i64>::sse_decode(deserializer);
        return crate::commons::udto::UIPageCollectedComic {
            list: var_list,
            total: var_total,
            limit: var_limit,
            offset: var_offset,
        };
    }
}

impl SseDecode for crate::commons::udto::UIPageComicChapter {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_list = <Vec<crate::commons::udto::UIComicChapter>>::sse_decode(deserializer);
        let mut var_total = <i64>::sse_decode(deserializer);
        let mut var_limit = <i64>::sse_decode(deserializer);
        let mut var_offset = <i64>::sse_decode(deserializer);
        return crate::commons::udto::UIPageComicChapter {
            list: var_list,
            total: var_total,
            limit: var_limit,
            offset: var_offset,
        };
    }
}

impl SseDecode for crate::commons::udto::UIPageComicInExplore {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_list = <Vec<crate::commons::udto::UIComicInExplore>>::sse_decode(deserializer);
        let mut var_total = <i64>::sse_decode(deserializer);
        let mut var_limit = <i64>::sse_decode(deserializer);
        let mut var_offset = <i64>::sse_decode(deserializer);
        return crate::commons::udto::UIPageComicInExplore {
            list: var_list,
            total: var_total,
            limit: var_limit,
            offset: var_offset,
        };
    }
}

impl SseDecode for crate::commons::udto::UIPageRankItem {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_list = <Vec<crate::commons::udto::UIRankItem>>::sse_decode(deserializer);
        let mut var_total = <i64>::sse_decode(deserializer);
        let mut var_limit = <i64>::sse_decode(deserializer);
        let mut var_offset = <i64>::sse_decode(deserializer);
        return crate::commons::udto::UIPageRankItem {
            list: var_list,
            total: var_total,
            limit: var_limit,
            offset: var_offset,
        };
    }
}

impl SseDecode for crate::commons::udto::UIPageUIComicInList {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_list = <Vec<crate::commons::udto::UIComicInList>>::sse_decode(deserializer);
        let mut var_total = <i64>::sse_decode(deserializer);
        let mut var_limit = <i64>::sse_decode(deserializer);
        let mut var_offset = <i64>::sse_decode(deserializer);
        return crate::commons::udto::UIPageUIComicInList {
            list: var_list,
            total: var_total,
            limit: var_limit,
            offset: var_offset,
        };
    }
}

impl SseDecode for crate::commons::udto::UIPageUIViewLog {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_list = <Vec<crate::commons::udto::UIViewLog>>::sse_decode(deserializer);
        let mut var_total = <i64>::sse_decode(deserializer);
        let mut var_limit = <i64>::sse_decode(deserializer);
        let mut var_offset = <i64>::sse_decode(deserializer);
        return crate::commons::udto::UIPageUIViewLog {
            list: var_list,
            total: var_total,
            limit: var_limit,
            offset: var_offset,
        };
    }
}

impl SseDecode for crate::commons::udto::UIQueryDownloadComic {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_pathWord = <String>::sse_decode(deserializer);
        let mut var_alias = <Option<String>>::sse_decode(deserializer);
        let mut var_author = <String>::sse_decode(deserializer);
        let mut var_b404 = <bool>::sse_decode(deserializer);
        let mut var_bHidden = <bool>::sse_decode(deserializer);
        let mut var_ban = <i64>::sse_decode(deserializer);
        let mut var_brief = <String>::sse_decode(deserializer);
        let mut var_closeComment = <bool>::sse_decode(deserializer);
        let mut var_closeRoast = <bool>::sse_decode(deserializer);
        let mut var_cover = <String>::sse_decode(deserializer);
        let mut var_datetimeUpdated = <String>::sse_decode(deserializer);
        let mut var_females = <String>::sse_decode(deserializer);
        let mut var_freeType = <String>::sse_decode(deserializer);
        let mut var_imgType = <i64>::sse_decode(deserializer);
        let mut var_males = <String>::sse_decode(deserializer);
        let mut var_name = <String>::sse_decode(deserializer);
        let mut var_popular = <i64>::sse_decode(deserializer);
        let mut var_reclass = <String>::sse_decode(deserializer);
        let mut var_region = <String>::sse_decode(deserializer);
        let mut var_restrict1 = <String>::sse_decode(deserializer);
        let mut var_seoBaidu = <String>::sse_decode(deserializer);
        let mut var_status = <String>::sse_decode(deserializer);
        let mut var_theme = <String>::sse_decode(deserializer);
        let mut var_uuid = <String>::sse_decode(deserializer);
        let mut var_groups =
            <Vec<crate::commons::udto::UIQueryDownloadComicGroup>>::sse_decode(deserializer);
        let mut var_chapters =
            <Vec<crate::commons::udto::UIQueryDownloadComicChapter>>::sse_decode(deserializer);
        return crate::commons::udto::UIQueryDownloadComic {
            path_word: var_pathWord,
            alias: var_alias,
            author: var_author,
            b_404: var_b404,
            b_hidden: var_bHidden,
            ban: var_ban,
            brief: var_brief,
            close_comment: var_closeComment,
            close_roast: var_closeRoast,
            cover: var_cover,
            datetime_updated: var_datetimeUpdated,
            females: var_females,
            free_type: var_freeType,
            img_type: var_imgType,
            males: var_males,
            name: var_name,
            popular: var_popular,
            reclass: var_reclass,
            region: var_region,
            restrict1: var_restrict1,
            seo_baidu: var_seoBaidu,
            status: var_status,
            theme: var_theme,
            uuid: var_uuid,
            groups: var_groups,
            chapters: var_chapters,
        };
    }
}

impl SseDecode for crate::commons::udto::UIQueryDownloadComicChapter {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_comicPathWord = <String>::sse_decode(deserializer);
        let mut var_uuid = <String>::sse_decode(deserializer);
        let mut var_comicId = <String>::sse_decode(deserializer);
        let mut var_count = <i64>::sse_decode(deserializer);
        let mut var_datetimeCreated = <String>::sse_decode(deserializer);
        let mut var_groupPathWord = <String>::sse_decode(deserializer);
        let mut var_imgType = <i64>::sse_decode(deserializer);
        let mut var_index = <i64>::sse_decode(deserializer);
        let mut var_isLong = <bool>::sse_decode(deserializer);
        let mut var_name = <String>::sse_decode(deserializer);
        let mut var_news = <String>::sse_decode(deserializer);
        let mut var_next = <Option<String>>::sse_decode(deserializer);
        let mut var_ordered = <i64>::sse_decode(deserializer);
        let mut var_prev = <Option<String>>::sse_decode(deserializer);
        let mut var_size = <i64>::sse_decode(deserializer);
        let mut var_typeField = <i64>::sse_decode(deserializer);
        return crate::commons::udto::UIQueryDownloadComicChapter {
            comic_path_word: var_comicPathWord,
            uuid: var_uuid,
            comic_id: var_comicId,
            count: var_count,
            datetime_created: var_datetimeCreated,
            group_path_word: var_groupPathWord,
            img_type: var_imgType,
            index: var_index,
            is_long: var_isLong,
            name: var_name,
            news: var_news,
            next: var_next,
            ordered: var_ordered,
            prev: var_prev,
            size: var_size,
            type_field: var_typeField,
        };
    }
}

impl SseDecode for crate::commons::udto::UIQueryDownloadComicGroup {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_comicPathWord = <String>::sse_decode(deserializer);
        let mut var_groupPathWord = <String>::sse_decode(deserializer);
        let mut var_count = <i64>::sse_decode(deserializer);
        let mut var_name = <String>::sse_decode(deserializer);
        let mut var_groupRank = <i64>::sse_decode(deserializer);
        return crate::commons::udto::UIQueryDownloadComicGroup {
            comic_path_word: var_comicPathWord,
            group_path_word: var_groupPathWord,
            count: var_count,
            name: var_name,
            group_rank: var_groupRank,
        };
    }
}

impl SseDecode for crate::commons::udto::UIRankItem {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_comic = <crate::commons::udto::UIComicInList>::sse_decode(deserializer);
        let mut var_dateType = <i64>::sse_decode(deserializer);
        let mut var_popular = <i64>::sse_decode(deserializer);
        let mut var_riseNum = <i64>::sse_decode(deserializer);
        let mut var_riseSort = <i64>::sse_decode(deserializer);
        let mut var_sort = <i64>::sse_decode(deserializer);
        let mut var_sortLast = <i64>::sse_decode(deserializer);
        return crate::commons::udto::UIRankItem {
            comic: var_comic,
            date_type: var_dateType,
            popular: var_popular,
            rise_num: var_riseNum,
            rise_sort: var_riseSort,
            sort: var_sort,
            sort_last: var_sortLast,
        };
    }
}

impl SseDecode for crate::commons::udto::UIRegisterResult {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_state = <i64>::sse_decode(deserializer);
        let mut var_message = <String>::sse_decode(deserializer);
        let mut var_member =
            <Option<crate::copy_client::dtos::RegisterResult>>::sse_decode(deserializer);
        return crate::commons::udto::UIRegisterResult {
            state: var_state,
            message: var_message,
            member: var_member,
        };
    }
}

impl SseDecode for crate::commons::udto::UITags {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_ordering = <Vec<crate::copy_client::dtos::Tag>>::sse_decode(deserializer);
        let mut var_theme = <Vec<crate::commons::udto::UITheme>>::sse_decode(deserializer);
        let mut var_top = <Vec<crate::copy_client::dtos::Tag>>::sse_decode(deserializer);
        return crate::commons::udto::UITags {
            ordering: var_ordering,
            theme: var_theme,
            top: var_top,
        };
    }
}

impl SseDecode for crate::commons::udto::UITheme {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_count = <i64>::sse_decode(deserializer);
        let mut var_initials = <i64>::sse_decode(deserializer);
        let mut var_name = <String>::sse_decode(deserializer);
        let mut var_pathWord = <String>::sse_decode(deserializer);
        return crate::commons::udto::UITheme {
            count: var_count,
            initials: var_initials,
            name: var_name,
            path_word: var_pathWord,
        };
    }
}

impl SseDecode for crate::commons::udto::UIViewLog {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_comicPathWord = <String>::sse_decode(deserializer);
        let mut var_comicName = <String>::sse_decode(deserializer);
        let mut var_comicAuthors = <String>::sse_decode(deserializer);
        let mut var_comicCover = <String>::sse_decode(deserializer);
        let mut var_chapterUuid = <String>::sse_decode(deserializer);
        let mut var_chapterName = <String>::sse_decode(deserializer);
        let mut var_chapterOrdered = <i64>::sse_decode(deserializer);
        let mut var_chapterSize = <i64>::sse_decode(deserializer);
        let mut var_chapterCount = <i64>::sse_decode(deserializer);
        let mut var_pageRank = <i32>::sse_decode(deserializer);
        let mut var_viewTime = <i64>::sse_decode(deserializer);
        return crate::commons::udto::UIViewLog {
            comic_path_word: var_comicPathWord,
            comic_name: var_comicName,
            comic_authors: var_comicAuthors,
            comic_cover: var_comicCover,
            chapter_uuid: var_chapterUuid,
            chapter_name: var_chapterName,
            chapter_ordered: var_chapterOrdered,
            chapter_size: var_chapterSize,
            chapter_count: var_chapterCount,
            page_rank: var_pageRank,
            view_time: var_viewTime,
        };
    }
}

impl SseDecode for () {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {}
}

fn pde_ffi_dispatcher_primary_impl(
    func_id: i32,
    port: flutter_rust_bridge::for_generated::MessagePort,
    ptr: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len: i32,
    data_len: i32,
) {
    // Codec=Pde (Serialization + dispatch), see doc to use other codecs
    match func_id {
        26 => wire_append_download_impl(port, ptr, rust_vec_len, data_len),
        23 => wire_cache_image_impl(port, ptr, rust_vec_len, data_len),
        24 => wire_clean_cache_impl(port, ptr, rust_vec_len, data_len),
        22 => wire_collect_from_account_impl(port, ptr, rust_vec_len, data_len),
        21 => wire_collect_to_account_impl(port, ptr, rust_vec_len, data_len),
        10 => wire_comic_impl(port, ptr, rust_vec_len, data_len),
        13 => wire_comic_chapter_data_impl(port, ptr, rust_vec_len, data_len),
        11 => wire_comic_chapters_impl(port, ptr, rust_vec_len, data_len),
        12 => wire_comic_query_impl(port, ptr, rust_vec_len, data_len),
        16 => wire_comic_search_impl(port, ptr, rust_vec_len, data_len),
        25 => wire_delete_download_comic_impl(port, ptr, rust_vec_len, data_len),
        31 => wire_download_comic_chapters_impl(port, ptr, rust_vec_len, data_len),
        30 => wire_download_comic_groups_impl(port, ptr, rust_vec_len, data_len),
        32 => wire_download_comic_pages_impl(port, ptr, rust_vec_len, data_len),
        29 => wire_download_comics_impl(port, ptr, rust_vec_len, data_len),
        33 => wire_download_is_pause_impl(port, ptr, rust_vec_len, data_len),
        34 => wire_download_set_pause_impl(port, ptr, rust_vec_len, data_len),
        15 => wire_explorer_impl(port, ptr, rust_vec_len, data_len),
        36 => wire_exports_impl(port, ptr, rust_vec_len, data_len),
        19 => wire_find_comic_view_log_impl(port, ptr, rust_vec_len, data_len),
        3 => wire_get_proxy_impl(port, ptr, rust_vec_len, data_len),
        35 => wire_http_get_impl(port, ptr, rust_vec_len, data_len),
        27 => wire_in_download_chapter_uuid_impl(port, ptr, rust_vec_len, data_len),
        5 => wire_init_login_state_impl(port, ptr, rust_vec_len, data_len),
        20 => wire_list_comic_view_logs_impl(port, ptr, rust_vec_len, data_len),
        2 => wire_load_property_impl(port, ptr, rust_vec_len, data_len),
        6 => wire_login_impl(port, ptr, rust_vec_len, data_len),
        8 => wire_rank_impl(port, ptr, rust_vec_len, data_len),
        9 => wire_recommends_impl(port, ptr, rust_vec_len, data_len),
        7 => wire_register_impl(port, ptr, rust_vec_len, data_len),
        28 => wire_reset_fail_downloads_impl(port, ptr, rust_vec_len, data_len),
        1 => wire_save_property_impl(port, ptr, rust_vec_len, data_len),
        4 => wire_set_proxy_impl(port, ptr, rust_vec_len, data_len),
        14 => wire_tags_impl(port, ptr, rust_vec_len, data_len),
        18 => wire_view_chapter_page_impl(port, ptr, rust_vec_len, data_len),
        17 => wire_view_comic_info_impl(port, ptr, rust_vec_len, data_len),
        39 => wire_init_impl(port, ptr, rust_vec_len, data_len),
        37 => wire_init_app_impl(port, ptr, rust_vec_len, data_len),
        _ => unreachable!(),
    }
}

fn pde_ffi_dispatcher_sync_impl(
    func_id: i32,
    ptr: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len: i32,
    data_len: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    // Codec=Pde (Serialization + dispatch), see doc to use other codecs
    match func_id {
        38 => wire_desktop_root_impl(ptr, rust_vec_len, data_len),
        _ => unreachable!(),
    }
}

// Section: rust2dart

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::copy_client::dtos::Author {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.name.into_into_dart().into_dart(),
            self.alias.into_into_dart().into_dart(),
            self.path_word.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::copy_client::dtos::Author
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::copy_client::dtos::Author>
    for crate::copy_client::dtos::Author
{
    fn into_into_dart(self) -> crate::copy_client::dtos::Author {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::copy_client::dtos::Browse {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.chapter_id.into_into_dart().into_dart(),
            self.chapter_name.into_into_dart().into_dart(),
            self.chapter_uuid.into_into_dart().into_dart(),
            self.comic_id.into_into_dart().into_dart(),
            self.comic_uuid.into_into_dart().into_dart(),
            self.path_word.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::copy_client::dtos::Browse
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::copy_client::dtos::Browse>
    for crate::copy_client::dtos::Browse
{
    fn into_into_dart(self) -> crate::copy_client::dtos::Browse {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::copy_client::dtos::ChapterComicInfo {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.name.into_into_dart().into_dart(),
            self.path_word.into_into_dart().into_dart(),
            self.restrict.into_into_dart().into_dart(),
            self.uuid.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::copy_client::dtos::ChapterComicInfo
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::copy_client::dtos::ChapterComicInfo>
    for crate::copy_client::dtos::ChapterComicInfo
{
    fn into_into_dart(self) -> crate::copy_client::dtos::ChapterComicInfo {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::copy_client::dtos::ChapterImage {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.url.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::copy_client::dtos::ChapterImage
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::copy_client::dtos::ChapterImage>
    for crate::copy_client::dtos::ChapterImage
{
    fn into_into_dart(self) -> crate::copy_client::dtos::ChapterImage {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::copy_client::dtos::ClassifyItem {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.display.into_into_dart().into_dart(),
            self.value.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::copy_client::dtos::ClassifyItem
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::copy_client::dtos::ClassifyItem>
    for crate::copy_client::dtos::ClassifyItem
{
    fn into_into_dart(self) -> crate::copy_client::dtos::ClassifyItem {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::copy_client::dtos::CollectedComic {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.uuid.into_into_dart().into_dart(),
            self.name.into_into_dart().into_dart(),
            self.b_folder.into_into_dart().into_dart(),
            self.folder_id.into_into_dart().into_dart(),
            self.last_browse.into_into_dart().into_dart(),
            self.comic.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::copy_client::dtos::CollectedComic
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::copy_client::dtos::CollectedComic>
    for crate::copy_client::dtos::CollectedComic
{
    fn into_into_dart(self) -> crate::copy_client::dtos::CollectedComic {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::copy_client::dtos::CollectedComicInfo {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.uuid.into_into_dart().into_dart(),
            self.b_display.into_into_dart().into_dart(),
            self.name.into_into_dart().into_dart(),
            self.path_word.into_into_dart().into_dart(),
            self.females.into_into_dart().into_dart(),
            self.males.into_into_dart().into_dart(),
            self.author.into_into_dart().into_dart(),
            self.theme.into_into_dart().into_dart(),
            self.cover.into_into_dart().into_dart(),
            self.status.into_into_dart().into_dart(),
            self.popular.into_into_dart().into_dart(),
            self.datetime_updated.into_into_dart().into_dart(),
            self.last_chapter_id.into_into_dart().into_dart(),
            self.last_chapter_name.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::copy_client::dtos::CollectedComicInfo
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::copy_client::dtos::CollectedComicInfo>
    for crate::copy_client::dtos::CollectedComicInfo
{
    fn into_into_dart(self) -> crate::copy_client::dtos::CollectedComicInfo {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::commons::udto::ExportsType {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            Self::Folder => 0.into_dart(),
            Self::Zip => 1.into_dart(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::commons::udto::ExportsType
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::commons::udto::ExportsType>
    for crate::commons::udto::ExportsType
{
    fn into_into_dart(self) -> crate::commons::udto::ExportsType {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::copy_client::dtos::Group {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.count.into_into_dart().into_dart(),
            self.name.into_into_dart().into_dart(),
            self.path_word.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::copy_client::dtos::Group
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::copy_client::dtos::Group>
    for crate::copy_client::dtos::Group
{
    fn into_into_dart(self) -> crate::copy_client::dtos::Group {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::copy_client::dtos::LastBrowse {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.last_browse_id.into_into_dart().into_dart(),
            self.last_browse_name.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::copy_client::dtos::LastBrowse
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::copy_client::dtos::LastBrowse>
    for crate::copy_client::dtos::LastBrowse
{
    fn into_into_dart(self) -> crate::copy_client::dtos::LastBrowse {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::copy_client::dtos::LastChapter {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.name.into_into_dart().into_dart(),
            self.uuid.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::copy_client::dtos::LastChapter
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::copy_client::dtos::LastChapter>
    for crate::copy_client::dtos::LastChapter
{
    fn into_into_dart(self) -> crate::copy_client::dtos::LastChapter {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::copy_client::dtos::MemberInfo {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.user_id.into_into_dart().into_dart(),
            self.username.into_into_dart().into_dart(),
            self.nickname.into_into_dart().into_dart(),
            self.avatar.into_into_dart().into_dart(),
            self.is_authenticated.into_into_dart().into_dart(),
            self.datetime_created.into_into_dart().into_dart(),
            self.b_verify_email.into_into_dart().into_dart(),
            self.email.into_into_dart().into_dart(),
            self.mobile.into_into_dart().into_dart(),
            self.mobile_region.into_into_dart().into_dart(),
            self.point.into_into_dart().into_dart(),
            self.comic_vip.into_into_dart().into_dart(),
            self.comic_vip_end.into_into_dart().into_dart(),
            self.comic_vip_start.into_into_dart().into_dart(),
            self.cartoon_vip.into_into_dart().into_dart(),
            self.cartoon_vip_end.into_into_dart().into_dart(),
            self.cartoon_vip_start.into_into_dart().into_dart(),
            self.ads_vip_end.into_into_dart().into_dart(),
            self.close_report.into_into_dart().into_dart(),
            self.downloads.into_into_dart().into_dart(),
            self.vip_downloads.into_into_dart().into_dart(),
            self.reward_downloads.into_into_dart().into_dart(),
            self.invite_code.into_into_dart().into_dart(),
            self.invited.into_into_dart().into_dart(),
            self.b_sstv.into_into_dart().into_dart(),
            self.scy_answer.into_into_dart().into_dart(),
            self.day_downloads_refresh.into_into_dart().into_dart(),
            self.day_downloads.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::copy_client::dtos::MemberInfo
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::copy_client::dtos::MemberInfo>
    for crate::copy_client::dtos::MemberInfo
{
    fn into_into_dart(self) -> crate::copy_client::dtos::MemberInfo {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::copy_client::dtos::RegisterResult {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.user_id.into_into_dart().into_dart(),
            self.uuid.into_into_dart().into_dart(),
            self.datetime_created.into_into_dart().into_dart(),
            self.token.into_into_dart().into_dart(),
            self.nickname.into_into_dart().into_dart(),
            self.avatar.into_into_dart().into_dart(),
            self.invite_code.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::copy_client::dtos::RegisterResult
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::copy_client::dtos::RegisterResult>
    for crate::copy_client::dtos::RegisterResult
{
    fn into_into_dart(self) -> crate::copy_client::dtos::RegisterResult {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::copy_client::dtos::SexualOrientation {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.name.into_into_dart().into_dart(),
            self.path_word.into_into_dart().into_dart(),
            self.gender.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::copy_client::dtos::SexualOrientation
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::copy_client::dtos::SexualOrientation>
    for crate::copy_client::dtos::SexualOrientation
{
    fn into_into_dart(self) -> crate::copy_client::dtos::SexualOrientation {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::copy_client::dtos::Tag {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.name.into_into_dart().into_dart(),
            self.path_word.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::copy_client::dtos::Tag {}
impl flutter_rust_bridge::IntoIntoDart<crate::copy_client::dtos::Tag>
    for crate::copy_client::dtos::Tag
{
    fn into_into_dart(self) -> crate::copy_client::dtos::Tag {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::commons::udto::UICacheImage {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.abs_path.into_into_dart().into_dart(),
            self.cache_key.into_into_dart().into_dart(),
            self.cache_time.into_into_dart().into_dart(),
            self.url.into_into_dart().into_dart(),
            self.useful.into_into_dart().into_dart(),
            self.extends_field_first.into_into_dart().into_dart(),
            self.extends_field_second.into_into_dart().into_dart(),
            self.extends_field_third.into_into_dart().into_dart(),
            self.local_path.into_into_dart().into_dart(),
            self.image_format.into_into_dart().into_dart(),
            self.image_width.into_into_dart().into_dart(),
            self.image_height.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::commons::udto::UICacheImage
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::commons::udto::UICacheImage>
    for crate::commons::udto::UICacheImage
{
    fn into_into_dart(self) -> crate::commons::udto::UICacheImage {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::commons::udto::UIChapterAndContents {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.comic_id.into_into_dart().into_dart(),
            self.comic_path_word.into_into_dart().into_dart(),
            self.contents.into_into_dart().into_dart(),
            self.count.into_into_dart().into_dart(),
            self.datetime_created.into_into_dart().into_dart(),
            self.group_path_word.into_into_dart().into_dart(),
            self.img_type.into_into_dart().into_dart(),
            self.index.into_into_dart().into_dart(),
            self.is_long.into_into_dart().into_dart(),
            self.name.into_into_dart().into_dart(),
            self.news.into_into_dart().into_dart(),
            self.next.into_into_dart().into_dart(),
            self.ordered.into_into_dart().into_dart(),
            self.prev.into_into_dart().into_dart(),
            self.size.into_into_dart().into_dart(),
            self.type_field.into_into_dart().into_dart(),
            self.uuid.into_into_dart().into_dart(),
            self.words.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::commons::udto::UIChapterAndContents
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::commons::udto::UIChapterAndContents>
    for crate::commons::udto::UIChapterAndContents
{
    fn into_into_dart(self) -> crate::commons::udto::UIChapterAndContents {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::commons::udto::UIChapterData {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.chapter.into_into_dart().into_dart(),
            self.comic.into_into_dart().into_dart(),
            self.is_lock.into_into_dart().into_dart(),
            self.is_login.into_into_dart().into_dart(),
            self.is_mobile_bind.into_into_dart().into_dart(),
            self.is_vip.into_into_dart().into_dart(),
            self.show_app.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::commons::udto::UIChapterData
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::commons::udto::UIChapterData>
    for crate::commons::udto::UIChapterData
{
    fn into_into_dart(self) -> crate::commons::udto::UIChapterData {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::commons::udto::UIComic {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.alias.into_into_dart().into_dart(),
            self.author.into_into_dart().into_dart(),
            self.b_404.into_into_dart().into_dart(),
            self.b_hidden.into_into_dart().into_dart(),
            self.ban.into_into_dart().into_dart(),
            self.brief.into_into_dart().into_dart(),
            self.close_comment.into_into_dart().into_dart(),
            self.close_roast.into_into_dart().into_dart(),
            self.cover.into_into_dart().into_dart(),
            self.datetime_updated.into_into_dart().into_dart(),
            self.free_type.into_into_dart().into_dart(),
            self.img_type.into_into_dart().into_dart(),
            self.last_chapter.into_into_dart().into_dart(),
            self.name.into_into_dart().into_dart(),
            self.path_word.into_into_dart().into_dart(),
            self.popular.into_into_dart().into_dart(),
            self.reclass.into_into_dart().into_dart(),
            self.region.into_into_dart().into_dart(),
            self.restrict.into_into_dart().into_dart(),
            self.seo_baidu.into_into_dart().into_dart(),
            self.status.into_into_dart().into_dart(),
            self.theme.into_into_dart().into_dart(),
            self.uuid.into_into_dart().into_dart(),
            self.females.into_into_dart().into_dart(),
            self.males.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::commons::udto::UIComic {}
impl flutter_rust_bridge::IntoIntoDart<crate::commons::udto::UIComic>
    for crate::commons::udto::UIComic
{
    fn into_into_dart(self) -> crate::commons::udto::UIComic {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::commons::udto::UIComicChapter {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.comic_id.into_into_dart().into_dart(),
            self.comic_path_word.into_into_dart().into_dart(),
            self.count.into_into_dart().into_dart(),
            self.datetime_created.into_into_dart().into_dart(),
            self.group_path_word.into_into_dart().into_dart(),
            self.img_type.into_into_dart().into_dart(),
            self.index.into_into_dart().into_dart(),
            self.name.into_into_dart().into_dart(),
            self.news.into_into_dart().into_dart(),
            self.next.into_into_dart().into_dart(),
            self.ordered.into_into_dart().into_dart(),
            self.prev.into_into_dart().into_dart(),
            self.size.into_into_dart().into_dart(),
            self.type_field.into_into_dart().into_dart(),
            self.uuid.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::commons::udto::UIComicChapter
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::commons::udto::UIComicChapter>
    for crate::commons::udto::UIComicChapter
{
    fn into_into_dart(self) -> crate::commons::udto::UIComicChapter {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::commons::udto::UIComicData {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.comic.into_into_dart().into_dart(),
            self.groups.into_into_dart().into_dart(),
            self.is_lock.into_into_dart().into_dart(),
            self.is_login.into_into_dart().into_dart(),
            self.is_mobile_bind.into_into_dart().into_dart(),
            self.is_vip.into_into_dart().into_dart(),
            self.popular.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::commons::udto::UIComicData
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::commons::udto::UIComicData>
    for crate::commons::udto::UIComicData
{
    fn into_into_dart(self) -> crate::commons::udto::UIComicData {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::commons::udto::UIComicInExplore {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.name.into_into_dart().into_dart(),
            self.path_word.into_into_dart().into_dart(),
            self.free_type.into_into_dart().into_dart(),
            self.author.into_into_dart().into_dart(),
            self.cover.into_into_dart().into_dart(),
            self.popular.into_into_dart().into_dart(),
            self.datetime_updated.into_into_dart().into_dart(),
            self.females.into_into_dart().into_dart(),
            self.males.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::commons::udto::UIComicInExplore
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::commons::udto::UIComicInExplore>
    for crate::commons::udto::UIComicInExplore
{
    fn into_into_dart(self) -> crate::commons::udto::UIComicInExplore {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::commons::udto::UIComicInList {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.author.into_into_dart().into_dart(),
            self.cover.into_into_dart().into_dart(),
            self.img_type.into_into_dart().into_dart(),
            self.name.into_into_dart().into_dart(),
            self.path_word.into_into_dart().into_dart(),
            self.popular.into_into_dart().into_dart(),
            self.females.into_into_dart().into_dart(),
            self.males.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::commons::udto::UIComicInList
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::commons::udto::UIComicInList>
    for crate::commons::udto::UIComicInList
{
    fn into_into_dart(self) -> crate::commons::udto::UIComicInList {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::commons::udto::UIComicQuery {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.browse.into_into_dart().into_dart(),
            self.collect.into_into_dart().into_dart(),
            self.is_lock.into_into_dart().into_dart(),
            self.is_login.into_into_dart().into_dart(),
            self.is_mobile_bind.into_into_dart().into_dart(),
            self.is_vip.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::commons::udto::UIComicQuery
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::commons::udto::UIComicQuery>
    for crate::commons::udto::UIComicQuery
{
    fn into_into_dart(self) -> crate::commons::udto::UIComicQuery {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::commons::udto::UIDownloadComic {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.path_word.into_into_dart().into_dart(),
            self.alias.into_into_dart().into_dart(),
            self.author.into_into_dart().into_dart(),
            self.b_404.into_into_dart().into_dart(),
            self.b_hidden.into_into_dart().into_dart(),
            self.ban.into_into_dart().into_dart(),
            self.brief.into_into_dart().into_dart(),
            self.close_comment.into_into_dart().into_dart(),
            self.close_roast.into_into_dart().into_dart(),
            self.cover.into_into_dart().into_dart(),
            self.datetime_updated.into_into_dart().into_dart(),
            self.females.into_into_dart().into_dart(),
            self.free_type.into_into_dart().into_dart(),
            self.img_type.into_into_dart().into_dart(),
            self.males.into_into_dart().into_dart(),
            self.name.into_into_dart().into_dart(),
            self.popular.into_into_dart().into_dart(),
            self.reclass.into_into_dart().into_dart(),
            self.region.into_into_dart().into_dart(),
            self.restrict.into_into_dart().into_dart(),
            self.seo_baidu.into_into_dart().into_dart(),
            self.status.into_into_dart().into_dart(),
            self.theme.into_into_dart().into_dart(),
            self.uuid.into_into_dart().into_dart(),
            self.cover_cache_key.into_into_dart().into_dart(),
            self.cover_download_status.into_into_dart().into_dart(),
            self.cover_format.into_into_dart().into_dart(),
            self.cover_width.into_into_dart().into_dart(),
            self.cover_height.into_into_dart().into_dart(),
            self.image_count.into_into_dart().into_dart(),
            self.image_count_success.into_into_dart().into_dart(),
            self.download_status.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::commons::udto::UIDownloadComic
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::commons::udto::UIDownloadComic>
    for crate::commons::udto::UIDownloadComic
{
    fn into_into_dart(self) -> crate::commons::udto::UIDownloadComic {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::commons::udto::UIDownloadComicChapter {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.comic_path_word.into_into_dart().into_dart(),
            self.uuid.into_into_dart().into_dart(),
            self.comic_id.into_into_dart().into_dart(),
            self.count.into_into_dart().into_dart(),
            self.datetime_created.into_into_dart().into_dart(),
            self.group_path_word.into_into_dart().into_dart(),
            self.img_type.into_into_dart().into_dart(),
            self.index.into_into_dart().into_dart(),
            self.is_long.into_into_dart().into_dart(),
            self.name.into_into_dart().into_dart(),
            self.news.into_into_dart().into_dart(),
            self.next.into_into_dart().into_dart(),
            self.ordered.into_into_dart().into_dart(),
            self.prev.into_into_dart().into_dart(),
            self.size.into_into_dart().into_dart(),
            self.type_field.into_into_dart().into_dart(),
            self.download_status.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::commons::udto::UIDownloadComicChapter
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::commons::udto::UIDownloadComicChapter>
    for crate::commons::udto::UIDownloadComicChapter
{
    fn into_into_dart(self) -> crate::commons::udto::UIDownloadComicChapter {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::commons::udto::UIDownloadComicGroup {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.comic_path_word.into_into_dart().into_dart(),
            self.group_path_word.into_into_dart().into_dart(),
            self.count.into_into_dart().into_dart(),
            self.name.into_into_dart().into_dart(),
            self.group_rank.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::commons::udto::UIDownloadComicGroup
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::commons::udto::UIDownloadComicGroup>
    for crate::commons::udto::UIDownloadComicGroup
{
    fn into_into_dart(self) -> crate::commons::udto::UIDownloadComicGroup {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::commons::udto::UIDownloadComicPage {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.comic_path_word.into_into_dart().into_dart(),
            self.chapter_uuid.into_into_dart().into_dart(),
            self.image_index.into_into_dart().into_dart(),
            self.url.into_into_dart().into_dart(),
            self.cache_key.into_into_dart().into_dart(),
            self.download_status.into_into_dart().into_dart(),
            self.width.into_into_dart().into_dart(),
            self.height.into_into_dart().into_dart(),
            self.format.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::commons::udto::UIDownloadComicPage
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::commons::udto::UIDownloadComicPage>
    for crate::commons::udto::UIDownloadComicPage
{
    fn into_into_dart(self) -> crate::commons::udto::UIDownloadComicPage {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::commons::udto::UILoginState {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.state.into_into_dart().into_dart(),
            self.message.into_into_dart().into_dart(),
            self.member.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::commons::udto::UILoginState
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::commons::udto::UILoginState>
    for crate::commons::udto::UILoginState
{
    fn into_into_dart(self) -> crate::commons::udto::UILoginState {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::commons::udto::UIPageCollectedComic {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.list.into_into_dart().into_dart(),
            self.total.into_into_dart().into_dart(),
            self.limit.into_into_dart().into_dart(),
            self.offset.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::commons::udto::UIPageCollectedComic
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::commons::udto::UIPageCollectedComic>
    for crate::commons::udto::UIPageCollectedComic
{
    fn into_into_dart(self) -> crate::commons::udto::UIPageCollectedComic {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::commons::udto::UIPageComicChapter {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.list.into_into_dart().into_dart(),
            self.total.into_into_dart().into_dart(),
            self.limit.into_into_dart().into_dart(),
            self.offset.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::commons::udto::UIPageComicChapter
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::commons::udto::UIPageComicChapter>
    for crate::commons::udto::UIPageComicChapter
{
    fn into_into_dart(self) -> crate::commons::udto::UIPageComicChapter {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::commons::udto::UIPageComicInExplore {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.list.into_into_dart().into_dart(),
            self.total.into_into_dart().into_dart(),
            self.limit.into_into_dart().into_dart(),
            self.offset.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::commons::udto::UIPageComicInExplore
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::commons::udto::UIPageComicInExplore>
    for crate::commons::udto::UIPageComicInExplore
{
    fn into_into_dart(self) -> crate::commons::udto::UIPageComicInExplore {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::commons::udto::UIPageRankItem {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.list.into_into_dart().into_dart(),
            self.total.into_into_dart().into_dart(),
            self.limit.into_into_dart().into_dart(),
            self.offset.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::commons::udto::UIPageRankItem
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::commons::udto::UIPageRankItem>
    for crate::commons::udto::UIPageRankItem
{
    fn into_into_dart(self) -> crate::commons::udto::UIPageRankItem {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::commons::udto::UIPageUIComicInList {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.list.into_into_dart().into_dart(),
            self.total.into_into_dart().into_dart(),
            self.limit.into_into_dart().into_dart(),
            self.offset.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::commons::udto::UIPageUIComicInList
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::commons::udto::UIPageUIComicInList>
    for crate::commons::udto::UIPageUIComicInList
{
    fn into_into_dart(self) -> crate::commons::udto::UIPageUIComicInList {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::commons::udto::UIPageUIViewLog {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.list.into_into_dart().into_dart(),
            self.total.into_into_dart().into_dart(),
            self.limit.into_into_dart().into_dart(),
            self.offset.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::commons::udto::UIPageUIViewLog
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::commons::udto::UIPageUIViewLog>
    for crate::commons::udto::UIPageUIViewLog
{
    fn into_into_dart(self) -> crate::commons::udto::UIPageUIViewLog {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::commons::udto::UIQueryDownloadComic {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.path_word.into_into_dart().into_dart(),
            self.alias.into_into_dart().into_dart(),
            self.author.into_into_dart().into_dart(),
            self.b_404.into_into_dart().into_dart(),
            self.b_hidden.into_into_dart().into_dart(),
            self.ban.into_into_dart().into_dart(),
            self.brief.into_into_dart().into_dart(),
            self.close_comment.into_into_dart().into_dart(),
            self.close_roast.into_into_dart().into_dart(),
            self.cover.into_into_dart().into_dart(),
            self.datetime_updated.into_into_dart().into_dart(),
            self.females.into_into_dart().into_dart(),
            self.free_type.into_into_dart().into_dart(),
            self.img_type.into_into_dart().into_dart(),
            self.males.into_into_dart().into_dart(),
            self.name.into_into_dart().into_dart(),
            self.popular.into_into_dart().into_dart(),
            self.reclass.into_into_dart().into_dart(),
            self.region.into_into_dart().into_dart(),
            self.restrict1.into_into_dart().into_dart(),
            self.seo_baidu.into_into_dart().into_dart(),
            self.status.into_into_dart().into_dart(),
            self.theme.into_into_dart().into_dart(),
            self.uuid.into_into_dart().into_dart(),
            self.groups.into_into_dart().into_dart(),
            self.chapters.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::commons::udto::UIQueryDownloadComic
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::commons::udto::UIQueryDownloadComic>
    for crate::commons::udto::UIQueryDownloadComic
{
    fn into_into_dart(self) -> crate::commons::udto::UIQueryDownloadComic {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::commons::udto::UIQueryDownloadComicChapter {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.comic_path_word.into_into_dart().into_dart(),
            self.uuid.into_into_dart().into_dart(),
            self.comic_id.into_into_dart().into_dart(),
            self.count.into_into_dart().into_dart(),
            self.datetime_created.into_into_dart().into_dart(),
            self.group_path_word.into_into_dart().into_dart(),
            self.img_type.into_into_dart().into_dart(),
            self.index.into_into_dart().into_dart(),
            self.is_long.into_into_dart().into_dart(),
            self.name.into_into_dart().into_dart(),
            self.news.into_into_dart().into_dart(),
            self.next.into_into_dart().into_dart(),
            self.ordered.into_into_dart().into_dart(),
            self.prev.into_into_dart().into_dart(),
            self.size.into_into_dart().into_dart(),
            self.type_field.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::commons::udto::UIQueryDownloadComicChapter
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::commons::udto::UIQueryDownloadComicChapter>
    for crate::commons::udto::UIQueryDownloadComicChapter
{
    fn into_into_dart(self) -> crate::commons::udto::UIQueryDownloadComicChapter {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::commons::udto::UIQueryDownloadComicGroup {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.comic_path_word.into_into_dart().into_dart(),
            self.group_path_word.into_into_dart().into_dart(),
            self.count.into_into_dart().into_dart(),
            self.name.into_into_dart().into_dart(),
            self.group_rank.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::commons::udto::UIQueryDownloadComicGroup
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::commons::udto::UIQueryDownloadComicGroup>
    for crate::commons::udto::UIQueryDownloadComicGroup
{
    fn into_into_dart(self) -> crate::commons::udto::UIQueryDownloadComicGroup {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::commons::udto::UIRankItem {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.comic.into_into_dart().into_dart(),
            self.date_type.into_into_dart().into_dart(),
            self.popular.into_into_dart().into_dart(),
            self.rise_num.into_into_dart().into_dart(),
            self.rise_sort.into_into_dart().into_dart(),
            self.sort.into_into_dart().into_dart(),
            self.sort_last.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::commons::udto::UIRankItem
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::commons::udto::UIRankItem>
    for crate::commons::udto::UIRankItem
{
    fn into_into_dart(self) -> crate::commons::udto::UIRankItem {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::commons::udto::UIRegisterResult {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.state.into_into_dart().into_dart(),
            self.message.into_into_dart().into_dart(),
            self.member.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::commons::udto::UIRegisterResult
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::commons::udto::UIRegisterResult>
    for crate::commons::udto::UIRegisterResult
{
    fn into_into_dart(self) -> crate::commons::udto::UIRegisterResult {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::commons::udto::UITags {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.ordering.into_into_dart().into_dart(),
            self.theme.into_into_dart().into_dart(),
            self.top.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::commons::udto::UITags {}
impl flutter_rust_bridge::IntoIntoDart<crate::commons::udto::UITags>
    for crate::commons::udto::UITags
{
    fn into_into_dart(self) -> crate::commons::udto::UITags {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::commons::udto::UITheme {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.count.into_into_dart().into_dart(),
            self.initials.into_into_dart().into_dart(),
            self.name.into_into_dart().into_dart(),
            self.path_word.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::commons::udto::UITheme {}
impl flutter_rust_bridge::IntoIntoDart<crate::commons::udto::UITheme>
    for crate::commons::udto::UITheme
{
    fn into_into_dart(self) -> crate::commons::udto::UITheme {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::commons::udto::UIViewLog {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.comic_path_word.into_into_dart().into_dart(),
            self.comic_name.into_into_dart().into_dart(),
            self.comic_authors.into_into_dart().into_dart(),
            self.comic_cover.into_into_dart().into_dart(),
            self.chapter_uuid.into_into_dart().into_dart(),
            self.chapter_name.into_into_dart().into_dart(),
            self.chapter_ordered.into_into_dart().into_dart(),
            self.chapter_size.into_into_dart().into_dart(),
            self.chapter_count.into_into_dart().into_dart(),
            self.page_rank.into_into_dart().into_dart(),
            self.view_time.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::commons::udto::UIViewLog
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::commons::udto::UIViewLog>
    for crate::commons::udto::UIViewLog
{
    fn into_into_dart(self) -> crate::commons::udto::UIViewLog {
        self
    }
}

impl SseEncode for flutter_rust_bridge::for_generated::anyhow::Error {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(format!("{:?}", self), serializer);
    }
}

impl SseEncode for String {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<u8>>::sse_encode(self.into_bytes(), serializer);
    }
}

impl SseEncode for crate::copy_client::dtos::Author {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.name, serializer);
        <Option<String>>::sse_encode(self.alias, serializer);
        <String>::sse_encode(self.path_word, serializer);
    }
}

impl SseEncode for bool {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_u8(self as _).unwrap();
    }
}

impl SseEncode for crate::copy_client::dtos::Browse {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.chapter_id, serializer);
        <String>::sse_encode(self.chapter_name, serializer);
        <String>::sse_encode(self.chapter_uuid, serializer);
        <String>::sse_encode(self.comic_id, serializer);
        <String>::sse_encode(self.comic_uuid, serializer);
        <String>::sse_encode(self.path_word, serializer);
    }
}

impl SseEncode for crate::copy_client::dtos::ChapterComicInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.name, serializer);
        <String>::sse_encode(self.path_word, serializer);
        <crate::copy_client::dtos::ClassifyItem>::sse_encode(self.restrict, serializer);
        <String>::sse_encode(self.uuid, serializer);
    }
}

impl SseEncode for crate::copy_client::dtos::ChapterImage {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.url, serializer);
    }
}

impl SseEncode for crate::copy_client::dtos::ClassifyItem {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.display, serializer);
        <i64>::sse_encode(self.value, serializer);
    }
}

impl SseEncode for crate::copy_client::dtos::CollectedComic {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i64>::sse_encode(self.uuid, serializer);
        <Option<String>>::sse_encode(self.name, serializer);
        <bool>::sse_encode(self.b_folder, serializer);
        <Option<String>>::sse_encode(self.folder_id, serializer);
        <Option<crate::copy_client::dtos::LastBrowse>>::sse_encode(self.last_browse, serializer);
        <crate::copy_client::dtos::CollectedComicInfo>::sse_encode(self.comic, serializer);
    }
}

impl SseEncode for crate::copy_client::dtos::CollectedComicInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.uuid, serializer);
        <bool>::sse_encode(self.b_display, serializer);
        <String>::sse_encode(self.name, serializer);
        <String>::sse_encode(self.path_word, serializer);
        <Vec<crate::copy_client::dtos::SexualOrientation>>::sse_encode(self.females, serializer);
        <Vec<crate::copy_client::dtos::SexualOrientation>>::sse_encode(self.males, serializer);
        <Vec<crate::copy_client::dtos::Author>>::sse_encode(self.author, serializer);
        <Vec<crate::copy_client::dtos::Tag>>::sse_encode(self.theme, serializer);
        <String>::sse_encode(self.cover, serializer);
        <i64>::sse_encode(self.status, serializer);
        <i64>::sse_encode(self.popular, serializer);
        <String>::sse_encode(self.datetime_updated, serializer);
        <String>::sse_encode(self.last_chapter_id, serializer);
        <String>::sse_encode(self.last_chapter_name, serializer);
    }
}

impl SseEncode for crate::commons::udto::ExportsType {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(
            match self {
                crate::commons::udto::ExportsType::Folder => 0,
                crate::commons::udto::ExportsType::Zip => 1,
                _ => {
                    unimplemented!("");
                }
            },
            serializer,
        );
    }
}

impl SseEncode for crate::copy_client::dtos::Group {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i64>::sse_encode(self.count, serializer);
        <String>::sse_encode(self.name, serializer);
        <String>::sse_encode(self.path_word, serializer);
    }
}

impl SseEncode for i32 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_i32::<NativeEndian>(self).unwrap();
    }
}

impl SseEncode for i64 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_i64::<NativeEndian>(self).unwrap();
    }
}

impl SseEncode for crate::copy_client::dtos::LastBrowse {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.last_browse_id, serializer);
        <String>::sse_encode(self.last_browse_name, serializer);
    }
}

impl SseEncode for crate::copy_client::dtos::LastChapter {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.name, serializer);
        <String>::sse_encode(self.uuid, serializer);
    }
}

impl SseEncode for Vec<String> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <String>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::copy_client::dtos::Author> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::copy_client::dtos::Author>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::copy_client::dtos::ChapterImage> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::copy_client::dtos::ChapterImage>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::copy_client::dtos::CollectedComic> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::copy_client::dtos::CollectedComic>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::copy_client::dtos::Group> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::copy_client::dtos::Group>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<i64> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <i64>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<u8> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <u8>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::copy_client::dtos::SexualOrientation> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::copy_client::dtos::SexualOrientation>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::copy_client::dtos::Tag> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::copy_client::dtos::Tag>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::commons::udto::UIComicChapter> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::commons::udto::UIComicChapter>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::commons::udto::UIComicInExplore> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::commons::udto::UIComicInExplore>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::commons::udto::UIComicInList> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::commons::udto::UIComicInList>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::commons::udto::UIDownloadComic> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::commons::udto::UIDownloadComic>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::commons::udto::UIDownloadComicChapter> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::commons::udto::UIDownloadComicChapter>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::commons::udto::UIDownloadComicGroup> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::commons::udto::UIDownloadComicGroup>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::commons::udto::UIDownloadComicPage> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::commons::udto::UIDownloadComicPage>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::commons::udto::UIQueryDownloadComicChapter> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::commons::udto::UIQueryDownloadComicChapter>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::commons::udto::UIQueryDownloadComicGroup> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::commons::udto::UIQueryDownloadComicGroup>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::commons::udto::UIRankItem> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::commons::udto::UIRankItem>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::commons::udto::UITheme> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::commons::udto::UITheme>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::commons::udto::UIViewLog> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::commons::udto::UIViewLog>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for crate::copy_client::dtos::MemberInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.user_id, serializer);
        <String>::sse_encode(self.username, serializer);
        <String>::sse_encode(self.nickname, serializer);
        <String>::sse_encode(self.avatar, serializer);
        <bool>::sse_encode(self.is_authenticated, serializer);
        <String>::sse_encode(self.datetime_created, serializer);
        <bool>::sse_encode(self.b_verify_email, serializer);
        <String>::sse_encode(self.email, serializer);
        <Option<String>>::sse_encode(self.mobile, serializer);
        <Option<String>>::sse_encode(self.mobile_region, serializer);
        <i64>::sse_encode(self.point, serializer);
        <i64>::sse_encode(self.comic_vip, serializer);
        <Option<String>>::sse_encode(self.comic_vip_end, serializer);
        <Option<String>>::sse_encode(self.comic_vip_start, serializer);
        <i64>::sse_encode(self.cartoon_vip, serializer);
        <Option<String>>::sse_encode(self.cartoon_vip_end, serializer);
        <Option<String>>::sse_encode(self.cartoon_vip_start, serializer);
        <Option<String>>::sse_encode(self.ads_vip_end, serializer);
        <bool>::sse_encode(self.close_report, serializer);
        <i64>::sse_encode(self.downloads, serializer);
        <i64>::sse_encode(self.vip_downloads, serializer);
        <i64>::sse_encode(self.reward_downloads, serializer);
        <Option<String>>::sse_encode(self.invite_code, serializer);
        <Option<String>>::sse_encode(self.invited, serializer);
        <bool>::sse_encode(self.b_sstv, serializer);
        <bool>::sse_encode(self.scy_answer, serializer);
        <String>::sse_encode(self.day_downloads_refresh, serializer);
        <i64>::sse_encode(self.day_downloads, serializer);
    }
}

impl SseEncode for Option<String> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <String>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::copy_client::dtos::Browse> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::copy_client::dtos::Browse>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<i64> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <i64>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::copy_client::dtos::LastBrowse> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::copy_client::dtos::LastBrowse>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::copy_client::dtos::MemberInfo> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::copy_client::dtos::MemberInfo>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::copy_client::dtos::RegisterResult> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::copy_client::dtos::RegisterResult>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::commons::udto::UIViewLog> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::commons::udto::UIViewLog>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for crate::copy_client::dtos::RegisterResult {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.user_id, serializer);
        <String>::sse_encode(self.uuid, serializer);
        <String>::sse_encode(self.datetime_created, serializer);
        <Option<String>>::sse_encode(self.token, serializer);
        <String>::sse_encode(self.nickname, serializer);
        <String>::sse_encode(self.avatar, serializer);
        <Option<String>>::sse_encode(self.invite_code, serializer);
    }
}

impl SseEncode for crate::copy_client::dtos::SexualOrientation {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.name, serializer);
        <String>::sse_encode(self.path_word, serializer);
        <i64>::sse_encode(self.gender, serializer);
    }
}

impl SseEncode for crate::copy_client::dtos::Tag {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.name, serializer);
        <String>::sse_encode(self.path_word, serializer);
    }
}

impl SseEncode for u32 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_u32::<NativeEndian>(self).unwrap();
    }
}

impl SseEncode for u64 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_u64::<NativeEndian>(self).unwrap();
    }
}

impl SseEncode for u8 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_u8(self).unwrap();
    }
}

impl SseEncode for crate::commons::udto::UICacheImage {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.abs_path, serializer);
        <String>::sse_encode(self.cache_key, serializer);
        <i64>::sse_encode(self.cache_time, serializer);
        <String>::sse_encode(self.url, serializer);
        <String>::sse_encode(self.useful, serializer);
        <Option<String>>::sse_encode(self.extends_field_first, serializer);
        <Option<String>>::sse_encode(self.extends_field_second, serializer);
        <Option<String>>::sse_encode(self.extends_field_third, serializer);
        <String>::sse_encode(self.local_path, serializer);
        <String>::sse_encode(self.image_format, serializer);
        <u32>::sse_encode(self.image_width, serializer);
        <u32>::sse_encode(self.image_height, serializer);
    }
}

impl SseEncode for crate::commons::udto::UIChapterAndContents {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.comic_id, serializer);
        <String>::sse_encode(self.comic_path_word, serializer);
        <Vec<crate::copy_client::dtos::ChapterImage>>::sse_encode(self.contents, serializer);
        <i64>::sse_encode(self.count, serializer);
        <String>::sse_encode(self.datetime_created, serializer);
        <String>::sse_encode(self.group_path_word, serializer);
        <i64>::sse_encode(self.img_type, serializer);
        <i64>::sse_encode(self.index, serializer);
        <bool>::sse_encode(self.is_long, serializer);
        <String>::sse_encode(self.name, serializer);
        <String>::sse_encode(self.news, serializer);
        <Option<String>>::sse_encode(self.next, serializer);
        <i64>::sse_encode(self.ordered, serializer);
        <Option<String>>::sse_encode(self.prev, serializer);
        <i64>::sse_encode(self.size, serializer);
        <i64>::sse_encode(self.type_field, serializer);
        <String>::sse_encode(self.uuid, serializer);
        <Vec<i64>>::sse_encode(self.words, serializer);
    }
}

impl SseEncode for crate::commons::udto::UIChapterData {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <crate::commons::udto::UIChapterAndContents>::sse_encode(self.chapter, serializer);
        <crate::copy_client::dtos::ChapterComicInfo>::sse_encode(self.comic, serializer);
        <bool>::sse_encode(self.is_lock, serializer);
        <bool>::sse_encode(self.is_login, serializer);
        <bool>::sse_encode(self.is_mobile_bind, serializer);
        <bool>::sse_encode(self.is_vip, serializer);
        <bool>::sse_encode(self.show_app, serializer);
    }
}

impl SseEncode for crate::commons::udto::UIComic {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Option<String>>::sse_encode(self.alias, serializer);
        <Vec<crate::copy_client::dtos::Author>>::sse_encode(self.author, serializer);
        <bool>::sse_encode(self.b_404, serializer);
        <bool>::sse_encode(self.b_hidden, serializer);
        <i64>::sse_encode(self.ban, serializer);
        <String>::sse_encode(self.brief, serializer);
        <bool>::sse_encode(self.close_comment, serializer);
        <bool>::sse_encode(self.close_roast, serializer);
        <String>::sse_encode(self.cover, serializer);
        <String>::sse_encode(self.datetime_updated, serializer);
        <crate::copy_client::dtos::ClassifyItem>::sse_encode(self.free_type, serializer);
        <i64>::sse_encode(self.img_type, serializer);
        <crate::copy_client::dtos::LastChapter>::sse_encode(self.last_chapter, serializer);
        <String>::sse_encode(self.name, serializer);
        <String>::sse_encode(self.path_word, serializer);
        <i64>::sse_encode(self.popular, serializer);
        <crate::copy_client::dtos::ClassifyItem>::sse_encode(self.reclass, serializer);
        <crate::copy_client::dtos::ClassifyItem>::sse_encode(self.region, serializer);
        <crate::copy_client::dtos::ClassifyItem>::sse_encode(self.restrict, serializer);
        <String>::sse_encode(self.seo_baidu, serializer);
        <crate::copy_client::dtos::ClassifyItem>::sse_encode(self.status, serializer);
        <Vec<crate::copy_client::dtos::Tag>>::sse_encode(self.theme, serializer);
        <String>::sse_encode(self.uuid, serializer);
        <Vec<crate::copy_client::dtos::SexualOrientation>>::sse_encode(self.females, serializer);
        <Vec<crate::copy_client::dtos::SexualOrientation>>::sse_encode(self.males, serializer);
    }
}

impl SseEncode for crate::commons::udto::UIComicChapter {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.comic_id, serializer);
        <String>::sse_encode(self.comic_path_word, serializer);
        <i64>::sse_encode(self.count, serializer);
        <String>::sse_encode(self.datetime_created, serializer);
        <String>::sse_encode(self.group_path_word, serializer);
        <i64>::sse_encode(self.img_type, serializer);
        <i64>::sse_encode(self.index, serializer);
        <String>::sse_encode(self.name, serializer);
        <String>::sse_encode(self.news, serializer);
        <Option<String>>::sse_encode(self.next, serializer);
        <i64>::sse_encode(self.ordered, serializer);
        <Option<String>>::sse_encode(self.prev, serializer);
        <i64>::sse_encode(self.size, serializer);
        <i64>::sse_encode(self.type_field, serializer);
        <String>::sse_encode(self.uuid, serializer);
    }
}

impl SseEncode for crate::commons::udto::UIComicData {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <crate::commons::udto::UIComic>::sse_encode(self.comic, serializer);
        <Vec<crate::copy_client::dtos::Group>>::sse_encode(self.groups, serializer);
        <bool>::sse_encode(self.is_lock, serializer);
        <bool>::sse_encode(self.is_login, serializer);
        <bool>::sse_encode(self.is_mobile_bind, serializer);
        <bool>::sse_encode(self.is_vip, serializer);
        <i64>::sse_encode(self.popular, serializer);
    }
}

impl SseEncode for crate::commons::udto::UIComicInExplore {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.name, serializer);
        <String>::sse_encode(self.path_word, serializer);
        <crate::copy_client::dtos::ClassifyItem>::sse_encode(self.free_type, serializer);
        <Vec<crate::copy_client::dtos::Author>>::sse_encode(self.author, serializer);
        <String>::sse_encode(self.cover, serializer);
        <i64>::sse_encode(self.popular, serializer);
        <Option<String>>::sse_encode(self.datetime_updated, serializer);
        <Vec<crate::copy_client::dtos::SexualOrientation>>::sse_encode(self.females, serializer);
        <Vec<crate::copy_client::dtos::SexualOrientation>>::sse_encode(self.males, serializer);
    }
}

impl SseEncode for crate::commons::udto::UIComicInList {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<crate::copy_client::dtos::Author>>::sse_encode(self.author, serializer);
        <String>::sse_encode(self.cover, serializer);
        <i64>::sse_encode(self.img_type, serializer);
        <String>::sse_encode(self.name, serializer);
        <String>::sse_encode(self.path_word, serializer);
        <i64>::sse_encode(self.popular, serializer);
        <Vec<crate::copy_client::dtos::SexualOrientation>>::sse_encode(self.females, serializer);
        <Vec<crate::copy_client::dtos::SexualOrientation>>::sse_encode(self.males, serializer);
    }
}

impl SseEncode for crate::commons::udto::UIComicQuery {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Option<crate::copy_client::dtos::Browse>>::sse_encode(self.browse, serializer);
        <Option<i64>>::sse_encode(self.collect, serializer);
        <bool>::sse_encode(self.is_lock, serializer);
        <bool>::sse_encode(self.is_login, serializer);
        <bool>::sse_encode(self.is_mobile_bind, serializer);
        <bool>::sse_encode(self.is_vip, serializer);
    }
}

impl SseEncode for crate::commons::udto::UIDownloadComic {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.path_word, serializer);
        <Option<String>>::sse_encode(self.alias, serializer);
        <String>::sse_encode(self.author, serializer);
        <bool>::sse_encode(self.b_404, serializer);
        <bool>::sse_encode(self.b_hidden, serializer);
        <i64>::sse_encode(self.ban, serializer);
        <String>::sse_encode(self.brief, serializer);
        <bool>::sse_encode(self.close_comment, serializer);
        <bool>::sse_encode(self.close_roast, serializer);
        <String>::sse_encode(self.cover, serializer);
        <String>::sse_encode(self.datetime_updated, serializer);
        <String>::sse_encode(self.females, serializer);
        <String>::sse_encode(self.free_type, serializer);
        <i64>::sse_encode(self.img_type, serializer);
        <String>::sse_encode(self.males, serializer);
        <String>::sse_encode(self.name, serializer);
        <i64>::sse_encode(self.popular, serializer);
        <String>::sse_encode(self.reclass, serializer);
        <String>::sse_encode(self.region, serializer);
        <String>::sse_encode(self.restrict, serializer);
        <String>::sse_encode(self.seo_baidu, serializer);
        <String>::sse_encode(self.status, serializer);
        <String>::sse_encode(self.theme, serializer);
        <String>::sse_encode(self.uuid, serializer);
        <String>::sse_encode(self.cover_cache_key, serializer);
        <i64>::sse_encode(self.cover_download_status, serializer);
        <String>::sse_encode(self.cover_format, serializer);
        <u32>::sse_encode(self.cover_width, serializer);
        <u32>::sse_encode(self.cover_height, serializer);
        <i64>::sse_encode(self.image_count, serializer);
        <i64>::sse_encode(self.image_count_success, serializer);
        <i64>::sse_encode(self.download_status, serializer);
    }
}

impl SseEncode for crate::commons::udto::UIDownloadComicChapter {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.comic_path_word, serializer);
        <String>::sse_encode(self.uuid, serializer);
        <String>::sse_encode(self.comic_id, serializer);
        <i64>::sse_encode(self.count, serializer);
        <String>::sse_encode(self.datetime_created, serializer);
        <String>::sse_encode(self.group_path_word, serializer);
        <i64>::sse_encode(self.img_type, serializer);
        <i64>::sse_encode(self.index, serializer);
        <bool>::sse_encode(self.is_long, serializer);
        <String>::sse_encode(self.name, serializer);
        <String>::sse_encode(self.news, serializer);
        <Option<String>>::sse_encode(self.next, serializer);
        <i64>::sse_encode(self.ordered, serializer);
        <Option<String>>::sse_encode(self.prev, serializer);
        <i64>::sse_encode(self.size, serializer);
        <i64>::sse_encode(self.type_field, serializer);
        <i64>::sse_encode(self.download_status, serializer);
    }
}

impl SseEncode for crate::commons::udto::UIDownloadComicGroup {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.comic_path_word, serializer);
        <String>::sse_encode(self.group_path_word, serializer);
        <i64>::sse_encode(self.count, serializer);
        <String>::sse_encode(self.name, serializer);
        <i64>::sse_encode(self.group_rank, serializer);
    }
}

impl SseEncode for crate::commons::udto::UIDownloadComicPage {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.comic_path_word, serializer);
        <String>::sse_encode(self.chapter_uuid, serializer);
        <i32>::sse_encode(self.image_index, serializer);
        <String>::sse_encode(self.url, serializer);
        <String>::sse_encode(self.cache_key, serializer);
        <i64>::sse_encode(self.download_status, serializer);
        <u32>::sse_encode(self.width, serializer);
        <u32>::sse_encode(self.height, serializer);
        <String>::sse_encode(self.format, serializer);
    }
}

impl SseEncode for crate::commons::udto::UILoginState {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i64>::sse_encode(self.state, serializer);
        <String>::sse_encode(self.message, serializer);
        <Option<crate::copy_client::dtos::MemberInfo>>::sse_encode(self.member, serializer);
    }
}

impl SseEncode for crate::commons::udto::UIPageCollectedComic {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<crate::copy_client::dtos::CollectedComic>>::sse_encode(self.list, serializer);
        <i64>::sse_encode(self.total, serializer);
        <i64>::sse_encode(self.limit, serializer);
        <i64>::sse_encode(self.offset, serializer);
    }
}

impl SseEncode for crate::commons::udto::UIPageComicChapter {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<crate::commons::udto::UIComicChapter>>::sse_encode(self.list, serializer);
        <i64>::sse_encode(self.total, serializer);
        <i64>::sse_encode(self.limit, serializer);
        <i64>::sse_encode(self.offset, serializer);
    }
}

impl SseEncode for crate::commons::udto::UIPageComicInExplore {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<crate::commons::udto::UIComicInExplore>>::sse_encode(self.list, serializer);
        <i64>::sse_encode(self.total, serializer);
        <i64>::sse_encode(self.limit, serializer);
        <i64>::sse_encode(self.offset, serializer);
    }
}

impl SseEncode for crate::commons::udto::UIPageRankItem {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<crate::commons::udto::UIRankItem>>::sse_encode(self.list, serializer);
        <i64>::sse_encode(self.total, serializer);
        <i64>::sse_encode(self.limit, serializer);
        <i64>::sse_encode(self.offset, serializer);
    }
}

impl SseEncode for crate::commons::udto::UIPageUIComicInList {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<crate::commons::udto::UIComicInList>>::sse_encode(self.list, serializer);
        <i64>::sse_encode(self.total, serializer);
        <i64>::sse_encode(self.limit, serializer);
        <i64>::sse_encode(self.offset, serializer);
    }
}

impl SseEncode for crate::commons::udto::UIPageUIViewLog {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<crate::commons::udto::UIViewLog>>::sse_encode(self.list, serializer);
        <i64>::sse_encode(self.total, serializer);
        <i64>::sse_encode(self.limit, serializer);
        <i64>::sse_encode(self.offset, serializer);
    }
}

impl SseEncode for crate::commons::udto::UIQueryDownloadComic {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.path_word, serializer);
        <Option<String>>::sse_encode(self.alias, serializer);
        <String>::sse_encode(self.author, serializer);
        <bool>::sse_encode(self.b_404, serializer);
        <bool>::sse_encode(self.b_hidden, serializer);
        <i64>::sse_encode(self.ban, serializer);
        <String>::sse_encode(self.brief, serializer);
        <bool>::sse_encode(self.close_comment, serializer);
        <bool>::sse_encode(self.close_roast, serializer);
        <String>::sse_encode(self.cover, serializer);
        <String>::sse_encode(self.datetime_updated, serializer);
        <String>::sse_encode(self.females, serializer);
        <String>::sse_encode(self.free_type, serializer);
        <i64>::sse_encode(self.img_type, serializer);
        <String>::sse_encode(self.males, serializer);
        <String>::sse_encode(self.name, serializer);
        <i64>::sse_encode(self.popular, serializer);
        <String>::sse_encode(self.reclass, serializer);
        <String>::sse_encode(self.region, serializer);
        <String>::sse_encode(self.restrict1, serializer);
        <String>::sse_encode(self.seo_baidu, serializer);
        <String>::sse_encode(self.status, serializer);
        <String>::sse_encode(self.theme, serializer);
        <String>::sse_encode(self.uuid, serializer);
        <Vec<crate::commons::udto::UIQueryDownloadComicGroup>>::sse_encode(self.groups, serializer);
        <Vec<crate::commons::udto::UIQueryDownloadComicChapter>>::sse_encode(
            self.chapters,
            serializer,
        );
    }
}

impl SseEncode for crate::commons::udto::UIQueryDownloadComicChapter {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.comic_path_word, serializer);
        <String>::sse_encode(self.uuid, serializer);
        <String>::sse_encode(self.comic_id, serializer);
        <i64>::sse_encode(self.count, serializer);
        <String>::sse_encode(self.datetime_created, serializer);
        <String>::sse_encode(self.group_path_word, serializer);
        <i64>::sse_encode(self.img_type, serializer);
        <i64>::sse_encode(self.index, serializer);
        <bool>::sse_encode(self.is_long, serializer);
        <String>::sse_encode(self.name, serializer);
        <String>::sse_encode(self.news, serializer);
        <Option<String>>::sse_encode(self.next, serializer);
        <i64>::sse_encode(self.ordered, serializer);
        <Option<String>>::sse_encode(self.prev, serializer);
        <i64>::sse_encode(self.size, serializer);
        <i64>::sse_encode(self.type_field, serializer);
    }
}

impl SseEncode for crate::commons::udto::UIQueryDownloadComicGroup {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.comic_path_word, serializer);
        <String>::sse_encode(self.group_path_word, serializer);
        <i64>::sse_encode(self.count, serializer);
        <String>::sse_encode(self.name, serializer);
        <i64>::sse_encode(self.group_rank, serializer);
    }
}

impl SseEncode for crate::commons::udto::UIRankItem {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <crate::commons::udto::UIComicInList>::sse_encode(self.comic, serializer);
        <i64>::sse_encode(self.date_type, serializer);
        <i64>::sse_encode(self.popular, serializer);
        <i64>::sse_encode(self.rise_num, serializer);
        <i64>::sse_encode(self.rise_sort, serializer);
        <i64>::sse_encode(self.sort, serializer);
        <i64>::sse_encode(self.sort_last, serializer);
    }
}

impl SseEncode for crate::commons::udto::UIRegisterResult {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i64>::sse_encode(self.state, serializer);
        <String>::sse_encode(self.message, serializer);
        <Option<crate::copy_client::dtos::RegisterResult>>::sse_encode(self.member, serializer);
    }
}

impl SseEncode for crate::commons::udto::UITags {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<crate::copy_client::dtos::Tag>>::sse_encode(self.ordering, serializer);
        <Vec<crate::commons::udto::UITheme>>::sse_encode(self.theme, serializer);
        <Vec<crate::copy_client::dtos::Tag>>::sse_encode(self.top, serializer);
    }
}

impl SseEncode for crate::commons::udto::UITheme {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i64>::sse_encode(self.count, serializer);
        <i64>::sse_encode(self.initials, serializer);
        <String>::sse_encode(self.name, serializer);
        <String>::sse_encode(self.path_word, serializer);
    }
}

impl SseEncode for crate::commons::udto::UIViewLog {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.comic_path_word, serializer);
        <String>::sse_encode(self.comic_name, serializer);
        <String>::sse_encode(self.comic_authors, serializer);
        <String>::sse_encode(self.comic_cover, serializer);
        <String>::sse_encode(self.chapter_uuid, serializer);
        <String>::sse_encode(self.chapter_name, serializer);
        <i64>::sse_encode(self.chapter_ordered, serializer);
        <i64>::sse_encode(self.chapter_size, serializer);
        <i64>::sse_encode(self.chapter_count, serializer);
        <i32>::sse_encode(self.page_rank, serializer);
        <i64>::sse_encode(self.view_time, serializer);
    }
}

impl SseEncode for () {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {}
}

#[cfg(not(target_family = "wasm"))]
#[path = "frb_generated.io.rs"]
mod io;
#[cfg(not(target_family = "wasm"))]
pub use io::*;

/// cbindgen:ignore
#[cfg(target_family = "wasm")]
#[path = "frb_generated.web.rs"]
mod web;
#[cfg(target_family = "wasm")]
pub use web::*;
